// Generated by dts-bundle-generator v6.12.0

/**
 * Creates a WebGL GLSL Shader Program.
 * @param {WebGLCanvas} gl
 * @param {string} vertexShaderSource
 * @param {string} fragmentShaderSource
 */
export declare function ShaderProgram(gl: WebGLCanvas, vertexShaderSource: string, fragmentShaderSource: string): void;
export declare class ShaderProgram {
	/**
	 * Creates a WebGL GLSL Shader Program.
	 * @param {WebGLCanvas} gl
	 * @param {string} vertexShaderSource
	 * @param {string} fragmentShaderSource
	 */
	constructor(gl: WebGLCanvas, vertexShaderSource: string, fragmentShaderSource: string);
	/**
	 * Reference to the WebGLCanvas.
	 * @readonly @type {WebGLCanvas}
	 */
	readonly gl: WebGLCanvas;
	/**
	 * Vertex shader resource object.
	 * @readonly @type {WebGLShader}
	 */
	readonly vertexShader: WebGLShader;
	/**
	 * Fragment shader resource object.
	 * @readonly @type {WebGLShader}
	 */
	readonly fragmentShader: WebGLShader;
	/**
	 * Shader program resource object.
	 * @readonly @type {WebGLProgram}
	 */
	readonly program: WebGLProgram;
	/**
	 * Links the program and throws an error if there was any problem.
	 * @throws {Error}
	 */
	linkProgram(): void;
	/**
	 * Binds an attribute location to the shader program.
	 * @param {number} attribLocation
	 * @param {string} attribName
	 */
	bindAttribLocation(attribLocation: number, attribName: string): void;
	/**
	 * Returns the location of a uniform variable.
	 * @param {string} uniformName
	 * @returns {WebGLUniformLocation}
	 */
	getUniformLocation(uniformName: string): WebGLUniformLocation;
	/**
	 * Returns the location of one or more uniform variables.
	 * @param {Array<string>} uniformNames
	 * @returns {Array<WebGLUniformLocation>}
	 */
	getUniformLocations(uniformNames: Array<string>): Array<WebGLUniformLocation>;
	/**
	 * Activates the shader program for subsequent drawing operations.
	 */
	useProgram(): void;
}
export declare namespace ShaderProgram {
	const attribLocations: Map<string, number>;
	/**
	 * Binds a global attribute location to be applied to any newly created shader program.
	 * @param {number} attribLocation
	 * @param {string} attribName
	 */
	function bindAttribLocation(attribLocation: number, attribName: string): void;
	/**
	 * Binds several global attribute locations to be applied to any newly created shader program.
	 * @param {Map<string, number>} attribs
	 */
	function bindAttribLocations(attribs: Map<string, number>): void;
}
/**
 * Creates a Vertex Array Object (VAO).
 * @param {WebGLCanvas} gl
 */
export declare function VertexArrayObject(gl: WebGLCanvas): void;
export declare class VertexArrayObject {
	/**
	 * Creates a Vertex Array Object (VAO).
	 * @param {WebGLCanvas} gl
	 */
	constructor(gl: WebGLCanvas);
	/**
	 * Reference to the WebGLCanvas.
	 * @readonly @type {WebGLCanvas}
	 */
	readonly gl: WebGLCanvas;
	/**
	 * Vertex array object resource.
	 * @type {WebGLVertexArrayObject}
	 */
	vertexArray: WebGLVertexArrayObject;
	/**
	 * Binds the vertex array object to the GPU.
	 */
	bindVertexArray(): void;
	/**
	 * Unbinds the vertex array object from the GPU.
	 */
	unbindVertexArray(): void;
}
/**
 * Represents a WebGL buffer.
 */
export declare class Buffer {
	/**
	 * Creates a WebGL buffer.
	 * @param {WebGLCanvas} gl
	 * @param {number} target
	 * @param {number} usage
	 */
	constructor(gl: WebGLCanvas, target: number, usage: number);
	/**
	 * Reference to the WebGLCanvas.
	 * @readonly @type {WebGLCanvas}
	 */
	readonly gl: WebGLCanvas;
	/**
	 * Buffer target.
	 * @type {number}
	 */
	target: number;
	/**
	 * Buffer usage mode.
	 * @type {number}
	 */
	usage: number;
	/**
	 * Buffer object resource.
	 * @type {WebGLBuffer}
	 */
	buffer: WebGLBuffer;
	/**
	 * Binds the buffer to its WebGL target.
	 * @returns {Buffer}
	 */
	bindBuffer(): Buffer;
	/**
	 * Initializes and creates the buffer object's data store.
	 * @param {ArrayBufferView} srcData
	 * @param {number} srcOffset?
	 * @returns {Buffer}
	 */
	bufferData(srcData: ArrayBufferView, srcOffset?: number): Buffer;
	/**
	 * Deletes the buffer.
	 */
	deleteBuffer(): void;
}
export declare class VertexBuffer extends Buffer {
	/**
	 * Creates a VertexBuffer linked to the ARRAY_BUFFER target.
	 * @param {WebGLCanvas} gl
	 * @param {number} usage
	 */
	constructor(gl: WebGLCanvas, usage: number);
}
export declare class ElementBuffer extends Buffer {
	/**
	 * Creates a ElementBuffer linked to the ELEMENT_ARRAY_BUFFER target.
	 * @param {WebGLCanvas} gl
	 * @param {number} usage
	 */
	constructor(gl: WebGLCanvas, usage: number);
}
export type WebGLCanvasOptions = {
	/**
	 * Positions the canvas to cover the entire screen. default `true`
	 */
	fullscreen?: boolean;
	/**
	 * Indicates if the stencil buffer should be enabled. default `false`
	 */
	stencil?: boolean;
	/**
	 * Background color, must be a 6-digit hex RGB value. default `#000000`
	 */
	background?: string;
	/**
	 * Width of the canvas, used only when `fullscreen` is `false`. default `960`
	 */
	width?: number;
	/**
	 * Height of the canvas, used only when `fullscreen` is `false`. default `540`
	 */
	height?: number;
};
/**
 * High performance WebGL2 Canvas.
 * @extends {WebGL2RenderingContext}
 * @param {WebGLCanvasOptions} [options]
 */
export declare function WebGLCanvas(options?: WebGLCanvasOptions): void;
export declare class WebGLCanvas {
	/**
	 * High performance WebGL2 Canvas.
	 * @extends {WebGL2RenderingContext}
	 * @param {WebGLCanvasOptions} [options]
	 */
	constructor(options?: WebGLCanvasOptions);
	/**
	 * WebGL2 Context.
	 * @type {WebGL2RenderingContext}
	 * @readonly
	 */
	readonly gl: WebGL2RenderingContext;
	/**
	 * Underlying HTML5 canvas element.
	 * @type {HTMLCanvasElement}
	 * @readonly
	 */
	readonly canvas: HTMLCanvasElement;
	private init;
	/**
	 * Creates a shader program with the specified vertex and fragment shader source codes.
	 * @param {string} vertexShaderSource
	 * @param {string} fragmentShaderSource
	 * @returns {ShaderProgram}
	 */
	createShaderProgram(vertexShaderSource: string, fragmentShaderSource: string): ShaderProgram;
	/**
	 * Creates a new vertex array object.
	 * @returns {VertexArrayObject}
	 */
	createVertexArrayObject(): VertexArrayObject;
	/**
	 * Creates a new vertex buffer.
	 * @param {number} usage Possible values are: `STATIC_DRAW`, `DYNAMIC_DRAW`, `STREAM_DRAW`, `STATIC_READ`, `DYNAMIC_READ`, `STREAM_READ`, `STATIC_COPY`, `DYNAMIC_COPY`, or `STREAM_COPY`.
	 * @returns {VertexBuffer}
	 */
	createVertexBuffer(usage: number): VertexBuffer;
	/**
	 * Creates a new element buffer.
	 * @param {number} usage Possible values are: `STATIC_DRAW`, `DYNAMIC_DRAW`, `STREAM_DRAW`, `STATIC_READ`, `DYNAMIC_READ`, `STREAM_READ`, `STATIC_COPY`, `DYNAMIC_COPY`, or `STREAM_COPY`.
	 * @returns {ElementBuffer}
	 */
	createElementBuffer(usage: number): ElementBuffer;
}

export {};
