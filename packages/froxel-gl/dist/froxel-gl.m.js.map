{"mappings":"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","sources":["<anon>","../../../../lib/js/froxel/packages/froxel-gl/src/main.js","../../../../lib/js/froxel/packages/froxel-gl/src/webgl-canvas.js","../../../../lib/js/froxel/packages/froxel-gl/src/shader-program.js","../../../../lib/js/froxel/packages/froxel-gl/src/uniform-buffer.js","../../../../lib/js/froxel/packages/froxel-gl/src/buffer.js","../../../../lib/js/froxel/packages/froxel-gl/src/vertex-buffer.js","../../../../lib/js/froxel/packages/froxel-gl/src/element-buffer.js","../../../../lib/js/froxel/packages/froxel-gl/src/vertex-array.js","../../../../lib/js/froxel/packages/froxel-gl/src/texture.js"],"sourcesContent":["import {Mat4 as $dvKFe$Mat4, Vec4 as $dvKFe$Vec4} from \"froxel-math\";\n\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\n\n\n\nclass $39446e84929489b5$export$2e2bcd8739ae039 {\n    /**\n\t * Reference to the WebGLCanvas.\n\t * @readonly @type {WebGLCanvas}\n\t */ gl;\n    /**\n\t * Buffer target.\n\t * @readonly @type {number}\n\t */ target;\n    /**\n\t * Buffer usage mode.\n\t * @readonly @type {number}\n\t */ usage;\n    /**\n\t * Buffer object resource.\n\t * @readonly @type {WebGLBuffer}\n\t */ buffer;\n    /**\n\t * Buffer size in bytes.\n\t * @readonly @type {number}\n\t */ byteLength;\n    /**\n\t * Source buffer, used for automatic upload of data to the GPU memory when `update` is called.\n\t * @readonly @type {Uint8Array}\n\t */ source;\n    /**\n\t * Creates a WebGL buffer.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} target\n\t * @param {number} usage\n\t */ constructor(gl, target, usage){\n        this.gl = gl;\n        this.target = target;\n        this.usage = usage;\n        this.buffer = gl.genBuffer();\n        this.byteLength = null;\n        this.source = null;\n    }\n    /**\n\t * Binds the buffer to its respective WebGL target.\n\t * @returns {Buffer}\n\t */ bindBuffer() {\n        if (this.gl.state.buffer[this.target] === this) return this;\n        this.gl.bindBuffer(this.target, this.buffer);\n        this.gl.state.buffer[this.target] = this;\n        return this;\n    }\n    /**\n\t * Unbinds the buffer from its GPU buffer target.\n\t * @returns {Buffer}\n\t */ unbindBuffer() {\n        this.gl.bindBuffer(this.target, null);\n        this.gl.state.buffer[this.target] = null;\n        return this;\n    }\n    /**\n\t * Allocates the specified number of bytes for the buffer.\n\t * @param {number} numBytes\n\t * @returns {Buffer}\n\t */ allocate(numBytes) {\n        this.bindBuffer();\n        this.gl.bufferData(this.target, numBytes, this.usage);\n        this.byteLength = numBytes;\n        return this;\n    }\n    /**\n\t * Initializes and creates the buffer object's data store.\n\t * @param {ArrayBufferView} srcData\n\t * @param {number} srcOffset?\n\t * @returns {Buffer}\n\t */ bufferData(srcData, srcOffset = 0) {\n        this.bindBuffer();\n        this.gl.bufferData(this.target, srcData, this.usage, srcOffset);\n        this.byteLength = this.gl.getBufferParameter(this.target, this.gl.BUFFER_SIZE);\n        return this;\n    }\n    /**\n\t * Updates a subset of the buffer object's data store. \n\t * @param {number} dstByteOffset\n\t * @param {ArrayBufferView} srcData\n\t * @param {number} srcOffset?\n\t * @param {number} length?\n\t * @returns {Buffer}\n\t */ bufferSubData(dstByteOffset, srcData, srcOffset = 0, length = 0) {\n        this.bindBuffer();\n        this.gl.bufferSubData(this.target, dstByteOffset, srcData, srcOffset, length ? length : srcData.length);\n        return this;\n    }\n    /**\n\t * Deletes the buffer.\n\t */ deleteBuffer() {\n        this.gl.deleteBuffer(this.buffer);\n    }\n    /**\n\t * Sets the buffer source. When not `null`, calling `update` will automatically upload the source buffer's data to the GPU.\n\t * @param {Uint8Array} buffer\n\t * @returns {Buffer}\n\t */ bufferSource(buffer) {\n        if (this.byteLength === null) this.bufferData(buffer);\n        this.source = buffer;\n        return this;\n    }\n    /**\n\t * Updates the buffer in the GPU with data from the source buffer (only when not `null`).\n\t * @param {number} byteOffset\n\t * @param {number} byteLength\n\t * @returns {Buffer}\n\t */ update(byteOffset = 0, byteLength = 0) {\n        if (this.source !== null) this.bufferSubData(byteOffset, this.source, byteOffset, byteLength);\n        return this;\n    }\n}\n\n\nclass $b16ed4ae54df03ae$export$2e2bcd8739ae039 extends (0, $39446e84929489b5$export$2e2bcd8739ae039) {\n    /**\n\t * Uniform block binding index. Set using `bindBufferBase`.\n\t * @readonly @type {number}\n\t */ bindingIndex;\n    /**\n\t * Creates a buffer for the UNIFORM_BUFFER target.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} usage\n\t */ constructor(gl, usage){\n        super(gl, gl.UNIFORM_BUFFER, usage);\n    }\n    /**\n\t * Binds the buffer to given index of the UNIFORM_BUFFER binding point.\n\t * @param {number} index\n\t * @returns {UniformBuffer}\n\t */ bufferIndex(index) {\n        this.gl.bindBufferBase(this.target, this.bindingIndex = index, this.buffer);\n        return this;\n    }\n}\n\n\nclass $6dde447a62899039$export$2e2bcd8739ae039 {\n    /**\n\t * Reference to the WebGLCanvas.\n\t * @readonly @type {WebGLCanvas}\n\t */ gl;\n    /**\n\t * Vertex shader resource object.\n\t * @private @type {WebGLShader}\n\t */ vertexShader;\n    /**\n\t * Fragment shader resource object.\n\t * @private @type {WebGLShader}\n\t */ fragmentShader;\n    /**\n\t * Fragment shader resource object.\n\t * @private @type {WebGLShader}\n\t */ geometryShader;\n    /**\n\t * Shader program resource object.\n\t * @readonly @type {WebGLProgram}\n\t */ program;\n    /**\n\t * Uniform and uniform block cache.\n\t * @private @type {object}\n\t */ cache;\n    /**\n\t * Creates a WebGL GLSL Shader Program.\n\t * @param {WebGLCanvas} gl\n\t * @param {string} vertexShaderSource\n\t * @param {string} fragmentShaderSource\n\t * @param {string} geometryShaderSource?\n\t */ constructor(gl, vertexShaderSource, fragmentShaderSource, geometryShaderSource = null){\n        this.gl = gl;\n        /* *** */ if (!vertexShaderSource.startsWith(\"#version\")) vertexShaderSource = \"#version 300 es\\nprecision highp float;\\n\" + vertexShaderSource;\n        this.vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(this.vertexShader, vertexShaderSource);\n        gl.compileShader(this.vertexShader);\n        /* *** */ if (!fragmentShaderSource.startsWith(\"#version\")) fragmentShaderSource = \"#version 300 es\\nprecision highp float;\\n\" + fragmentShaderSource;\n        this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(this.fragmentShader, fragmentShaderSource);\n        gl.compileShader(this.fragmentShader);\n        /* *** */ if (geometryShaderSource !== null) {\n            if (!geometryShaderSource.startsWith(\"#version\")) geometryShaderSource = \"#version 300 es\\nprecision highp float;\\n\" + geometryShaderSource;\n            this.geometryShader = gl.createShader(gl.GEOMETRY_SHADER);\n            gl.shaderSource(this.geometryShader, geometryShaderSource);\n            gl.compileShader(this.geometryShader);\n        } else this.geometryShader = null;\n        /* *** */ this.program = gl.createProgram();\n        gl.attachShader(this.program, this.vertexShader);\n        gl.attachShader(this.program, this.fragmentShader);\n        if (this.geometryShader) gl.attachShader(this.program, this.geometryShader);\n        this.cache = {\n            u: {},\n            b: {},\n            a: {}\n        };\n        this.linkProgram();\n    }\n    /**\n\t * Map of global attribute locations.\n\t * @readonly @private\n\t * @type {Map<string, number>}\n\t */ static attribLocations = new Map();\n    /**\n\t * Binds a global attribute location to be applied to any newly created shader program.\n\t * @param {number} attribLocation\n\t * @param {string} attribName\n\t */ static bindAttribLocation(attribLocation, attribName) {\n        if (typeof attribLocation === \"string\") throw new Error(\"bindAttribLocation: attribLocation should be a number\");\n        $6dde447a62899039$export$2e2bcd8739ae039.attribLocations[attribName] = attribLocation;\n    }\n    /**\n\t * Binds several global attribute locations to be applied to any newly created shader program.\n\t * @param {Map<string, number>} attribs\n\t */ static bindAttribLocations(attribs) {\n        for(let attribName in attribs)$6dde447a62899039$export$2e2bcd8739ae039.attribLocations[attribName] = attribs[attribName];\n    }\n    /**\n\t * Links the program and throws an error if there was any problem.\n\t * @private\n\t * @throws {Error}\n\t * @returns {ShaderProgram}\n\t */ linkProgram() {\n        for(let attribName in $6dde447a62899039$export$2e2bcd8739ae039.attribLocations)this.gl.bindAttribLocation(this.program, $6dde447a62899039$export$2e2bcd8739ae039.attribLocations[attribName], attribName);\n        this.gl.linkProgram(this.program);\n        if (this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {\n            this.gl.deleteShader(this.vertexShader);\n            this.gl.deleteShader(this.fragmentShader);\n            if (this.geometryShader) this.gl.deleteShader(this.geometryShader);\n            return this;\n        }\n        let vertexError = this.gl.getShaderInfoLog(this.vertexShader);\n        let fragmentError = this.gl.getShaderInfoLog(this.fragmentShader);\n        let geometryError = this.geometryShader ? this.gl.getShaderInfoLog(this.geometryShader) : \"\";\n        throw new Error(vertexError ? \"• Vertex Shader:\\n\" + vertexError + \"\\n\" : \"\" + geometryError ? \"• Geometry Shader:\\n\" + geometryError + \"\\n\" : \"\" + fragmentError ? \"• Fragment Shader:\\n\" + fragmentError : \"\");\n    }\n    /**\n\t * Binds an attribute location to the shader program.\n\t * @param {number} attribLocation\n\t * @param {string} attribName\n\t * @returns {ShaderProgram}\n\t */ bindAttribLocation(attribLocation, attribName) {\n        this.gl.bindAttribLocation(this.program, attribLocation, attribName);\n        return this;\n    }\n    /**\n\t * Returns the location of an attribute.\n\t * @param {string} attribName\n\t * @returns {WebGLUniformLocation}\n\t */ getAttribLocation(attribName) {\n        if (!(attribName in this.cache.u)) this.cache.a[attribName] = this.gl.getAttribLocation(this.program, attribName);\n        return this.cache.a[attribName];\n    }\n    /**\n\t * Returns the location of one or more attributes.\n\t * @param {Array<string>} attribNames\n\t * @returns { [key: string]: WebGLUniformLocation }\n\t */ getAttribLocations(attribNames) {\n        let attribs = {};\n        for (let uniformName of attribNames)attribs[uniformName] = this.getAttribLocation(uniformName);\n        return attribs;\n    }\n    /**\n\t * Activates the shader program for subsequent drawing operations.\n\t * @returns {ShaderProgram}\n\t */ useProgram() {\n        if (this.gl.state.program === this) return this;\n        this.gl.useProgram(this.program);\n        this.gl.state.program = this;\n        return this;\n    }\n    /**\n\t * Returns the location of a uniform variable.\n\t * @param {string} uniformName\n\t * @returns {WebGLUniformLocation}\n\t */ getUniformLocation(uniformName) {\n        if (!(uniformName in this.cache.u)) this.cache.u[uniformName] = this.gl.getUniformLocation(this.program, uniformName);\n        return this.cache.u[uniformName];\n    }\n    /**\n\t * Returns the location of one or more uniform variables.\n\t * @param {Array<string>} uniformNames\n\t * @returns { [key: string]: WebGLUniformLocation }\n\t */ getUniformLocations(uniformNames) {\n        let uniforms = {};\n        for (let uniformName of uniformNames)uniforms[uniformName] = this.getUniformLocation(uniformName);\n        return uniforms;\n    }\n    /**\n\t * Returns the index and offset of one or more uniform variables. Highly useful to build an appropriate uniform buffer object (UBO) when\n\t * the exact layout of the data is not known beforehand (but the uniform names are).\n\t * @param {Array<string>} uniformNames\n\t * @returns { [key: string]: { index: number, offset: number } }\n\t */ getUniformOffsets(uniformNames) {\n        let uniforms = {};\n        let indices = this.gl.getUniformIndices(this.program, uniformNames);\n        let offsets = this.gl.getActiveUniforms(this.program, indices, this.gl.UNIFORM_OFFSET);\n        for(let i in uniformNames)uniforms[uniformNames[i]] = {\n            index: indices[i],\n            offset: offsets[i]\n        };\n        return uniforms;\n    }\n    /**\n\t * Returns the index of a uniform block.\n\t * @param {string} blockName\n\t * @returns {number}\n\t */ getUniformBlockIndex(blockName) {\n        if (!(blockName in this.cache.b)) this.cache.b[blockName] = this.gl.getUniformBlockIndex(this.program, blockName);\n        return this.cache.b[blockName];\n    }\n    /**\n\t * Returns the indices of one or more uniform blocks.\n\t * @param {Array<string>} blockNames\n\t * @returns { [key: string]: number }\n\t */ getUniformBlockIndices(blockNames) {\n        let indices = {};\n        for (let blockName of blockNames)indices[blockName] = this.getUniformBlockIndex(blockName);\n        return indices;\n    }\n    /**\n\t * Binds a uniform buffer to a uniform block in the program.\n\t * @param {number|string} blockIdentifier\n\t * @param {number|UniformBuffer} bindingIndex\n\t * @returns {ShaderProgram}\n\t */ bindUniformBlock(blockIdentifier, bindingIndex) {\n        if (typeof blockIdentifier === \"string\") blockIdentifier = this.getUniformBlockIndex(blockIdentifier);\n        if (bindingIndex instanceof (0, $b16ed4ae54df03ae$export$2e2bcd8739ae039)) bindingIndex = bindingIndex.bindingIndex;\n        return this.gl.uniformBlockBinding(this.program, blockIdentifier, bindingIndex);\n    }\n}\n\n\n\n\nclass $36f5d74c5e4f8c80$export$2e2bcd8739ae039 extends (0, $39446e84929489b5$export$2e2bcd8739ae039) {\n    /**\n\t * Stride of the buffer.\n\t * @readonly @type {number}\n\t */ stride;\n    /**\n\t * Creates a buffer for the ARRAY_BUFFER target.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} usage\n\t */ constructor(gl, usage){\n        super(gl, gl.ARRAY_BUFFER, usage);\n    }\n    /**\n\t * Sets the stride of the vertex buffer.\n\t * @param {number} stride\n\t * @returns {VertexBuffer}\n\t */ bufferStride(stride) {\n        this.stride = stride;\n        return this;\n    }\n    /**\n\t * Configures a vertex attribute pointer.\n\t * @param {number} attribLocation - Location of the attribute within the shader program.\n\t * @param {number} dataSize - Number of bytes for this attribute.\n\t * @param {WebGLAttribType} dataType - Type of the attribute.\n\t * @param {number} byteOffset - Offset within the buffer to the first value.\n\t * @returns {VertexBuffer}\n\t */ attribPointer(attribLocation, dataSize, dataType, byteOffset = 0) {\n        this.bindBuffer();\n        this.gl.vertexAttribPointer(attribLocation, dataSize, this.gl[dataType], false, this.stride, byteOffset);\n        return this;\n    }\n    /**\n\t * Enables the attribute vertex array at the specified location.\n\t * @param {number} attribLocation \n\t * @returns {VertexBuffer}\n\t */ enableAttrib(attribLocation) {\n        this.bindBuffer();\n        this.gl.enableVertexAttribArray(attribLocation);\n        return this;\n    }\n    /**\n\t * Disables the attribute vertex array at the specified location.\n\t * @param {number} attribLocation\n\t * @returns {VertexBuffer}\n\t */ disableAttrib(attribLocation) {\n        this.bindBuffer();\n        this.gl.disableVertexAttribArray(attribLocation);\n        return this;\n    }\n}\n\n\n\n\nclass $2caa64557fc4247f$export$2e2bcd8739ae039 extends (0, $39446e84929489b5$export$2e2bcd8739ae039) {\n    /**\n\t * Creates a buffer for the ELEMENT_ARRAY_BUFFER target.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} usage\n\t */ constructor(gl, usage){\n        super(gl, gl.ELEMENT_ARRAY_BUFFER, usage);\n    }\n}\n\n\n\nvar $c676ea14144bdf07$export$2e2bcd8739ae039 = $c676ea14144bdf07$var$VertexArray;\n/**\n * Vertex Array Object (VAO) is a data structure that stores information about an associated element buffer, one or more vertex attribute\n * pointers, and also one or more vertex buffers.\n * @param {WebGLCanvas} gl\n */ function $c676ea14144bdf07$var$VertexArray(gl) {\n    /**\n\t * Reference to the WebGLCanvas.\n\t * @readonly @type {WebGLCanvas}\n\t */ this.gl = gl;\n    /**\n\t * Vertex array object resource.\n\t * @type {WebGLVertexArrayObject}\n\t */ this.vertexArray = gl.genVertexArray();\n}\n/**\n * Binds the vertex array object to the GPU.\n * @returns {VertexArray}\n */ $c676ea14144bdf07$var$VertexArray.prototype.bindVertexArray = function() {\n    if (this.gl.state.vertexArray === this) return this;\n    this.gl.bindVertexArray(this.vertexArray);\n    this.gl.state.vertexArray = this;\n    return this;\n};\n/**\n * Unbinds the vertex array object from the GPU.\n * @returns {VertexArray}\n */ $c676ea14144bdf07$var$VertexArray.prototype.unbindVertexArray = function() {\n    this.gl.bindVertexArray(null);\n    this.gl.state.vertexArray = null;\n    return this;\n};\n\n\n\n\nclass $d097352d58eb0afd$export$2e2bcd8739ae039 {\n    /**\n\t * Reference to the WebGLCanvas.\n\t * @readonly @type {WebGLCanvas}\n\t */ gl;\n    /**\n\t * Texture object resource.\n\t * @readonly @type {WebGLTexture}\n\t */ texture;\n    /**\n\t * Texture width (physical width).\n\t * @readonly @type {number}\n\t */ width;\n    /**\n\t * Texture height (physical height).\n\t * @readonly @type {number}\n\t */ height;\n    /**\n\t * Target width originally requested (logical width).\n\t * @readonly @type {number}\n\t */ targetWidth;\n    /**\n\t * Target height originally requested (logical height).\n\t * @readonly @type {number}\n\t */ targetHeight;\n    /**\n\t * Scale of the texture (physical width / logical width).\n\t * @readonly @type {number}\n\t */ scale;\n    /**\n\t * Texture filter type. Defaults to `LINEAR`.\n\t * @readonly @type {TextureFilterType}\n\t */ filterType;\n    /**\n\t * Texture wrap mode. Defaults to `CLAMP_TO_EDGE`.\n\t * @readonly @type {TextureWrapMode}\n\t */ wrapMode;\n    /**\n\t * Number of mipmap levels (use 0 to disable). Default is `0`.\n\t * @readonly @type {number}\n\t */ mipmapLevels;\n    /**\n\t * Indicates if the texture storage has already been allocated.\n\t * @readonly @private @type {boolean}\n\t */ allocated;\n    /**\n\t * Creates an empty texture object of the specified size.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} width - Physical texture width.\n\t * @param {number} height - Physical texture height.\n\t * @param {number} [targetWidth] - Logical texture width.\n\t * @param {number} [targetHeight] - Logical texture height.\n\t */ constructor(gl, width, height, targetWidth = null, targetHeight = null){\n        this.gl = gl;\n        this.texture = gl.genTexture();\n        this.width = width;\n        this.height = height;\n        this.targetWidth = targetWidth ?? width;\n        this.targetHeight = targetHeight ?? height;\n        this.scale = this.width / this.targetWidth;\n        this.allocated = false;\n        this.mipmapLevels = 0;\n        this.wrapMode = \"CLAMP_TO_EDGE\";\n        this.filterType = \"LINEAR\";\n    }\n    /**\n\t * Binds the texture to the `TEXTURE_2D` target and allocates the texture storage if not allocated yet.\n\t * @returns {Texture}\n\t */ bindTexture() {\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n        if (this.allocated !== false) return this;\n        this.allocated = null;\n        this.allocate();\n        return this;\n    }\n    /**\n\t * Allocates the texture storage.\n\t * @returns {Texture}\n\t */ allocate() {\n        if (this.allocated === true) return this;\n        this.allocated = true;\n        this.bindTexture().applyFilter().applyWrap();\n        if (this.mipmapLevels > 0) this.gl.texStorage2D(this.gl.TEXTURE_2D, this.mipmapLevels, this.gl.RGBA8, this.width, this.height);\n        else this.gl.texStorage2D(this.gl.TEXTURE_2D, 1, this.gl.RGBA8, this.width, this.height);\n        return this;\n    }\n    /**\n\t * Applies the texture filter.\n\t * @private\n\t * @param {boolean} [bindTexture]\n\t * @returns {Texture}\n\t */ applyFilter(bindTexture = false) {\n        if (bindTexture) this.bindTexture();\n        let minFilter = this.gl.LINEAR;\n        let magFilter = this.gl.LINEAR;\n        if (this.filterType === \"NEAREST\") minFilter = magFilter = this.gl.NEAREST;\n        if (this.mipmapLevels > 0) {\n            minFilter = this.gl.LINEAR_MIPMAP_LINEAR;\n            if (this.filterType === \"NEAREST\") minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n        }\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, minFilter);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, magFilter);\n        return this;\n    }\n    /**\n\t * Applies the texture wrap mode.\n\t * @private\n\t * @param {boolean} [bindTexture]\n\t * @returns {Texture}\n\t */ applyWrap(bindTexture = false) {\n        if (bindTexture) this.bindTexture();\n        let wrapMode = this.gl.CLAMP_TO_EDGE;\n        if (this.wrapMode === \"REPEAT\") wrapMode = this.gl.REPEAT;\n        else if (this.wrap === \"MIRRORED_REPEAT\") wrapMode = this.gl.MIRRORED_REPEAT;\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, wrapMode);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, wrapMode);\n        return this;\n    }\n    /**\n\t * Sets the texture filter type.\n\t * @param {TextureFilterType} filterType\n\t * @returns {Texture}\n\t */ setFilter(filterType) {\n        this.filterType = filterType;\n        return this.allocated === true ? this.applyFilter(true) : this;\n    }\n    /**\n\t * Sets the texture wrap mode.\n\t * @param {TextureWrapMode} wrapMode\n\t * @returns {Texture}\n\t */ setWrapMode(wrapMode) {\n        this.wrapMode = wrapMode;\n        return this.allocated === true ? this.applyWrap(true) : this;\n    }\n    /**\n\t * Sets the number of mipmap levels. Valid only if texture data has not been allocated yet.\n\t * @param {number} numLevels\n\t * @returns {Texture}\n\t */ setMipmapLevels(numLevels) {\n        if (this.allocated === true) return this;\n        this.mipmapLevels = Math.max(0, numLevels);\n        return this;\n    }\n    /**\n\t * Uploads data to the GPU from the specified image.\n\t * @param {HTMLImageElement} image\n\t * @param {number} [offsX] - Target X offset.\n\t * @param {number} [offsY] - Target Y offset;\n\t * @returns {Texture}\n\t */ upload(image, offsX = 0, offsY = 0) {\n        this.bindTexture();\n        this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, offsX, offsY, Math.min(image.width, this.width), Math.min(image.height, this.height), this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\n        if (this.mipmapLevels > 0) this.gl.generateMipmap(this.gl.TEXTURE_2D);\n        return this;\n    }\n    /**\n\t * Makes the texture active on the specified texture unit.\n\t * @param {number} unit - Texture unit index (0 to 15).\n\t * @returns {Texture}\n\t */ activeTexture(unit) {\n        this.gl.activeTexture(this.gl.TEXTURE0 + (unit & 15));\n        this.bindTexture();\n        return this;\n    }\n}\n\n\n\n\nvar $e3e474f4ae65cf0e$export$2e2bcd8739ae039 = $e3e474f4ae65cf0e$var$WebGLCanvas;\n/**\n * @typedef {'default'|'landscape'|'portrait'|'automatic'|'strict'} WebGLCanvasOrientation\n */ /**\n * @typedef {'ARRAY_BUFFER'|'ELEMENT_ARRAY_BUFFER'|'COPY_READ_BUFFER'|'COPY_WRITE_BUFFER'|'TRANSFORM_FEEDBACK_BUFFER'|'UNIFORM_BUFFER'|'PIXEL_PACK_BUFFER'|'PIXEL_UNPACK_BUFFER'} WebGLBufferTarget\n */ /**\n * @typedef {'STATIC_DRAW'|'DYNAMIC_DRAW'|'STREAM_DRAW'|'STATIC_READ'|'DYNAMIC_READ'|'STREAM_READ'|'STATIC_COPY'|'DYNAMIC_COPY'|'STREAM_COPY'} WebGLBufferUsage\n */ /**\n * @typedef {Object} WebGLCanvasOptions\n * @prop {boolean} [fullscreen] Positions the canvas to cover the entire screen. default `true`\n * @prop {boolean} [stencil] Indicates if the stencil buffer should be enabled. default `false`\n * @prop {string} [background] Background color, must be a 6-digit hex RGB value. default `000000`\n * @prop {number} [width] Width of the canvas, used only when `fullscreen` is `false`. default `960`\n * @prop {number} [height] Height of the canvas, used only when `fullscreen` is `false`. default `540`\n * @prop {WebGLCanvasOrientation} [orientation] Orientation of the canvas. Defaults to `AUTOMATIC`.\n * @prop {boolean} [antialias] Controls the antialias option, set to `false` for pixel-perfect output. Default is `true`.\n * @prop {number} [scaleFactorMax] Limit of the scale factor, used only when set to greater than zero.\n * @prop {number} [scaleFactorOffs] Offset used to increase the scale factor before the Math.floor operation. Default is `0.7`.\n */ const $e3e474f4ae65cf0e$var$defaultOptions = {\n    fullscreen: true,\n    stencil: false,\n    background: \"000000\",\n    width: 960,\n    height: 540,\n    orientation: \"automatic\",\n    antialias: true,\n    scaleFactorMax: 0,\n    scaleFactorOffs: 0.7\n};\n/**\n * List of active canvases. Registered when the WebGLCanvas is created, and removed when it is disposed.\n */ const $e3e474f4ae65cf0e$var$activeCanvases = [];\n/**\n * Indicates if the auto-resizer has been attached to the window.\n */ let $e3e474f4ae65cf0e$var$autoResizerAttached = false;\n/**\n * \n */ function $e3e474f4ae65cf0e$var$autoResizeCanvas(wgl) {\n    let fullWidth = wgl.options.width;\n    let fullHeight = wgl.options.height;\n    if (wgl.options.fullscreen && \"document\" in $parcel$global) {\n        fullWidth = Math.floor($parcel$global.innerWidth);\n        fullHeight = Math.floor($parcel$global.innerHeight);\n    } else {\n        if (wgl.options.width === null && wgl.options.height === null) throw new Error(\"At least one screen dimension must be specified in headless mode.\");\n    }\n    // Flip dimensions to ensure the desired orientation.\n    let currentWidth = fullWidth;\n    let currentHeight = fullHeight;\n    let flipped = false;\n    if (fullWidth < fullHeight && wgl.options.orientation === \"landscape\" || fullWidth > fullHeight && wgl.options.orientation === \"portrait\") {\n        currentWidth = fullHeight;\n        currentHeight = fullWidth;\n        flipped = true;\n    }\n    // Get target screen dimensions.\n    let targetWidth = wgl.options.width;\n    let targetHeight = wgl.options.height;\n    if (targetWidth === null || targetHeight === null) {\n        if (targetWidth === null && targetHeight === null) {\n            targetWidth = currentWidth;\n            targetHeight = currentHeight;\n        } else if (targetWidth === null) targetWidth = Math.floor(0.5 + currentWidth * (wgl.options.height / currentHeight));\n        else targetHeight = Math.floor(0.5 + currentHeight * (wgl.options.width / currentWidth));\n    }\n    // Handle `automatic` canvas orientation.\n    let screenWidth = targetWidth;\n    let screenHeight = targetHeight;\n    if (wgl.options.orientation === \"automatic\" && screenWidth && screenHeight) {\n        if (screenWidth > screenHeight && currentWidth < currentHeight || screenWidth < screenHeight && currentWidth > currentHeight) {\n            screenWidth = targetHeight;\n            screenHeight = targetWidth;\n        }\n    }\n    // Compute canvas scale factor.\n    let canvasScaleFactor = 1;\n    if (screenWidth && screenHeight) canvasScaleFactor = Math.min(currentWidth / screenWidth, currentHeight / screenHeight);\n    else if (screenWidth) canvasScaleFactor = currentWidth / screenWidth;\n    else if (screenHeight) canvasScaleFactor = currentHeight / screenHeight;\n    // ***\n    let tmpWidth = currentWidth;\n    let tmpHeight = currentHeight;\n    if (screenWidth) currentWidth = screenWidth;\n    if (screenHeight) currentHeight = screenHeight;\n    let offsX = Math.floor((tmpWidth - currentWidth * canvasScaleFactor) * 0.5);\n    let offsY = Math.floor((tmpHeight - currentHeight * canvasScaleFactor) * 0.5);\n    if (flipped) {\n        let tmp = offsX;\n        offsX = offsY;\n        offsY = tmp;\n    }\n    let scaleFactor = canvasScaleFactor * $parcel$global.devicePixelRatio;\n    scaleFactor = Math.floor(wgl.options.scaleFactorOffs + scaleFactor);\n    if (wgl.options.scaleFactorMax > 0 && scaleFactor > wgl.options.scaleFactorMax) scaleFactor = wgl.options.scaleFactorMax;\n    if (wgl.options.fullscreen && \"document\" in $parcel$global) $parcel$global.document.body.style.backgroundColor = wgl.element.style.backgroundColor;\n    wgl.resize(currentWidth, currentHeight, false);\n    if (!flipped) {\n        wgl.element.style.width = Math.floor(currentWidth * canvasScaleFactor + 0.5) + \"px\";\n        wgl.element.style.height = Math.floor(currentHeight * canvasScaleFactor + 0.5) + \"px\";\n    } else {\n        wgl.element.style.width = Math.floor(currentHeight * canvasScaleFactor + 0.5) + \"px\";\n        wgl.element.style.height = Math.floor(currentWidth * canvasScaleFactor + 0.5) + \"px\";\n    }\n    wgl.element.style.marginLeft = offsX + \"px\";\n    wgl.element.style.marginTop = offsY + \"px\";\n    wgl.globalScale = scaleFactor;\n    wgl.isFlipped = flipped;\n    wgl.u.initial.identity();\n    wgl.u.initial.scale(scaleFactor, scaleFactor, scaleFactor);\n    if (flipped) {\n        wgl.u.initial.rotateZ(Math.PI / 2);\n        wgl.u.initial.translate(-currentWidth, 0, 0);\n    }\n    wgl.updateViewport();\n//console.log('logical', wgl.width, wgl.height);\t\n//console.log('canvas-logical', wgl.element.width, wgl.element.height);\n//console.log('canvas-css', wgl.element.style.width, wgl.element.style.height);\n//console.log('phys', wgl.physWidth, wgl.physHeight);\n//console.log('webGl', wgl.gl.drawingBufferWidth, wgl.gl.drawingBufferHeight);\n//console.log('globalScale', wgl.globalScale);\n//console.log('canvasScaleFactor', canvasScaleFactor);\n/* *** */ //if (options.maxScaleFactor > 0 && scaleFactor > options.maxScaleFactor)\n//\tscaleFactor = options.maxScaleFactor;\n//_this.integerScaleFactor = Math.floor(scaleFactor + 0.5); //0.9\n}\n/**\n * WebGL2 Canvas.\n *\n * Default WebGL configuration is set as follows:\n *\n * - `DEPTH_TEST`: enabled, `clearDepth`: 1.0, `depthFunc`: LEQUAL\n * - `BLEND`: enabled, `blendEquationSeparate`: FUNC_ADD, FUNC_ADD, `blendFunc`: ONE, ONE_MINUS_SRC_ALPHA\n * - `UNPACK_PREMULTIPLY_ALPHA_WEBGL`: enabled\n * - `SCISSOR_TEST`: enabled\n *\n * @extends {WebGL2RenderingContext}\n * @param {WebGLCanvasOptions} [options]\n */ function $e3e474f4ae65cf0e$var$WebGLCanvas(options = null) {\n    if (!$e3e474f4ae65cf0e$var$autoResizerAttached) {\n        $parcel$global.onresize = function() {\n            for (let wgl of $e3e474f4ae65cf0e$var$activeCanvases)$e3e474f4ae65cf0e$var$autoResizeCanvas(wgl);\n        };\n        $e3e474f4ae65cf0e$var$autoResizerAttached = true;\n    }\n    this.init({\n        ...$e3e474f4ae65cf0e$var$defaultOptions,\n        ...options\n    });\n    $e3e474f4ae65cf0e$var$activeCanvases.push(this);\n}\n/**\n * Disposes the canvas and all related resources.\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.dispose = function() {\n    $e3e474f4ae65cf0e$var$activeCanvases.splice($e3e474f4ae65cf0e$var$activeCanvases.indexOf(this), 1);\n};\n/**\n * WebGL2 rendering context.\n * @private @readonly @type {WebGL2RenderingContext}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.gl = null;\n/**\n * Contains the state of several WebGL elements (shader program, bound buffer, texture, etc). This is a general object, and each class or interested party\n * is responsible for accesing and maintaining values in this object.\n * @private @type {object}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.state = null;\n/**\n * @typedef {Object} WebGLCanvasUniforms\n * @prop {boolean} changed Indicates if the uniforms have changed and should be reloaded in the WebGL program.\n * @prop {Mat4} initial Transformation to achieve correct target resolution and orientation (automatically set by WebGLCanvas).\n * @prop {Mat4} view Transforms coordinates to view space.\n * @prop {Mat4} projection Transforms coordinates to NDC space. Use the `setOrtho2D`, `setOrtho3D` or `setFrustrum` methods of Utils to configure its value.\n * @prop {Vec4} resolution Canvas resolution (automatically set by WebGLCanvas).\n */ /**\n * Common uniforms for WebGL. Note that it is the responsibility of the developer to set, configure and use these uniforms (except the ones marked\n * as \"automatically set by WebGLCanvas\"). Thse are provided solely as placeholders for easy access from a known interface.\n * @readonly @type {WebGLCanvasUniforms}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.u = null;\n/**\n * Underlying HTML5 canvas element.\n * @readonly @type {HTMLCanvasElement}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.element = null;\n/**\n * Logical width of the canvas.\n * @readonly @type {number}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.width = 0;\n/**\n * Logical height of the canvas.\n * @readonly @type {number}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.height = 0;\n/**\n * Physical canvas width.\n * @readonly @type {number}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.physWidth = 0;\n/**\n * Physical canvas height.\n * @readonly @type {number}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.physHeight = 0;\n/**\n * Indicates if the canvas is flipped.\n * @readonly @type {boolean}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.isFlipped = false;\n/**\n * Canvas global scale.\n * @readonly @type {number}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.globalScale = 1.0;\n/**\n * Functions that are under a different name in WebGLCanvas from the original WebGL2RenderingContext.\n */ const $e3e474f4ae65cf0e$var$renamedFunctions = {\n    createTexture: \"genTexture\",\n    createBuffer: \"genBuffer\",\n    createVertexArray: \"genVertexArray\"\n};\n/**\n * Initializes the instance.\n * @private\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.init = function(options) {\n    this.element = document.createElement(\"canvas\");\n    this.options = options;\n    if (!options.fullscreen && (!options.width || !options.height)) throw new Error(\"Option `width` or `height` is missing while `fullscreen` is `false`.\");\n    if (options.background.length != 6) throw new Error(\"Option `background` should be a 6-digit hex RGB (i.e. 000000).\");\n    this.element.style.imageRendering = options.antialias ? \"auto\" : \"crisp-edges\";\n    this.element.style.backgroundColor = \"#\" + options.background;\n    if (options.fullscreen) {\n        this.element.style.position = \"absolute\";\n        this.element.style.left = \"0px\";\n        this.element.style.top = \"0px\";\n    }\n    // Get WebGL context and re-bind functions and values to the WebGLCanvas object.\n    this.gl = this.element.getContext(\"webgl2\", {\n        desynchronized: false,\n        preserveDrawingBuffer: false,\n        alpha: false,\n        stencil: options.stencil\n    });\n    for(let prop in this.gl){\n        let val = this.gl[prop];\n        switch(typeof val){\n            case \"function\":\n                if (prop in $e3e474f4ae65cf0e$var$renamedFunctions) prop = $e3e474f4ae65cf0e$var$renamedFunctions[prop];\n                this[prop] = val.bind(this.gl);\n                break;\n            case \"number\":\n                this[prop] = val;\n                break;\n        }\n    }\n    console.log(this.getParameter(this.VERSION) + \", \" + this.getParameter(this.SHADING_LANGUAGE_VERSION));\n    // Global state object.\n    this.state = {\n        program: null,\n        buffer: {},\n        vertexArray: null\n    };\n    // Allocate placeholder for uniforms.\n    this.u = {\n        changed: true,\n        initial: (0, $dvKFe$Mat4).alloc(),\n        view: (0, $dvKFe$Mat4).alloc(),\n        projection: (0, $dvKFe$Mat4).alloc(),\n        resolution: (0, $dvKFe$Vec4).alloc()\n    };\n    // Initialize default configuration.\n    this.clearColor(parseInt(options.background.substring(0, 2), 16) / 255.0, parseInt(options.background.substring(2, 4), 16) / 255.0, parseInt(options.background.substring(4, 6), 16) / 255.0, 1.0);\n    this.colorMask(true, true, true, true);\n    this.enable(this.DEPTH_TEST);\n    this.clearDepth(1.0);\n    this.depthFunc(this.LEQUAL);\n    this.enable(this.BLEND);\n    this.pixelStorei(this.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n    this.blendEquationSeparate(this.FUNC_ADD, this.FUNC_ADD);\n    this.blendFunc(this.ONE, this.ONE_MINUS_SRC_ALPHA);\n    this.enable(this.SCISSOR_TEST);\n    $e3e474f4ae65cf0e$var$autoResizeCanvas(this);\n};\n/**\n * Resizes the canvas to the specified logical size.\n * @param {number} width\n * @param {number} height\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.resize = function(width, height, updateViewport = true) {\n    this.width = width;\n    this.height = height;\n    if (updateViewport) this.updateViewport();\n};\n// VIOLET: Possibly create a viewport object like the olden days.\n$e3e474f4ae65cf0e$var$WebGLCanvas.prototype.updateViewport = function() {\n    this.physWidth = this.element.width = Math.floor((this.isFlipped ? this.height : this.width) * this.globalScale);\n    this.physHeight = this.element.height = Math.floor((this.isFlipped ? this.width : this.height) * this.globalScale);\n    this.scissor(0, 0, this.physWidth, this.physHeight);\n    this.viewport(0, 0, this.physWidth, this.physHeight);\n    //violet:hardware scaling? currently we're using canvas browser-level scaling.\n    //this.v_resolution[0] = this._width;\n    //this.v_resolution[1] = this._height;\n    this.u.resolution.set(this.physWidth, this.physHeight, this.isFlipped ? this.physHeight : this.physWidth, this.isFlipped ? this.physWidth : this.physHeight);\n    this.u.changed = true;\n};\n/**\n * Creates a shader program with the specified vertex and fragment shader source codes.\n * @param {string} vertexShaderSource\n * @param {string} fragmentShaderSource\n * @param {string} geometryShaderSource?\n * @returns {ShaderProgram}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.createShaderProgram = function(vertexShaderSource, fragmentShaderSource, geometryShaderSource = null) {\n    return new (0, $6dde447a62899039$export$2e2bcd8739ae039)(this, vertexShaderSource, fragmentShaderSource, geometryShaderSource);\n};\n/**\n * Creates a new vertex array object.\n * @returns {VertexArray}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.createVertexArray = function() {\n    return new (0, $c676ea14144bdf07$export$2e2bcd8739ae039)(this);\n};\n/**\n * Creates a new buffer.\n * @param {WebGLBufferTarget} target\n * @param {WebGLBufferUsage} usage\n * @returns {VertexBuffer}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.createBuffer = function(target, usage) {\n    return new (0, $39446e84929489b5$export$2e2bcd8739ae039)(this, this[target], this[usage]);\n};\n/**\n * Creates a new vertex buffer.\n * @param {WebGLBufferUsage} usage\n * @returns {VertexBuffer}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.createVertexBuffer = function(usage) {\n    return new (0, $36f5d74c5e4f8c80$export$2e2bcd8739ae039)(this, this[usage]);\n};\n/**\n * Creates a new element buffer.\n * @param {WebGLBufferUsage} usage\n * @returns {ElementBuffer}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.createElementBuffer = function(usage) {\n    return new (0, $2caa64557fc4247f$export$2e2bcd8739ae039)(this, this[usage]);\n};\n/**\n * Creates a new uniform buffer object.\n * @param {WebGLBufferUsage} usage\n * @returns {UniformBuffer}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.createUniformBuffer = function(usage) {\n    return new (0, $b16ed4ae54df03ae$export$2e2bcd8739ae039)(this, this[usage]);\n};\n/**\n * Creates a new texture object of the specified size.\n * @param {number} width - Physical texture width.\n * @param {number} height - Physical texture height.\n * @param {number} [targetWidth] - Logical texture width.\n * @param {number} [targetHeight] - Logical texture height.\n * @returns {Texture}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.createTexture = function(width, height, targetWidth = null, targetHeight = null) {\n    return new (0, $d097352d58eb0afd$export$2e2bcd8739ae039)(this, width, height, targetWidth, targetHeight);\n};\n/**\n * Loads an image from the specified URL.\n * @param {string} url\n * @returns {Promise<HTMLImageElement>}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.loadImage = function(url) {\n    return new Promise((resolve, reject)=>{\n        let img = new Image();\n        img.onload = ()=>resolve(img);\n        img.onerror = ()=>reject(\"Unable to load image: \" + url);\n        img.src = url;\n    });\n};\n/**\n * Loads an image from the specified URL and creates a texture.\n * @param {string} url\n * @param {number} [mipmapLevels] - Number of levels for mipmapping. Defaults to `0`.\n * @returns {Promise<Texture>}\n */ $e3e474f4ae65cf0e$var$WebGLCanvas.prototype.loadTextureFromUrl = async function(url, mipmapLevels = 0) {\n    let image = await $e3e474f4ae65cf0e$var$WebGLCanvas.loadImage(url);\n    let texture = this.createTexture(image.width, image.height);\n    texture.setMipmapLevels(mipmapLevels);\n    texture.upload(image);\n    return texture;\n};\n\n\n\n\n\n\n\n\n\n\n\nexport {$e3e474f4ae65cf0e$export$2e2bcd8739ae039 as WebGLCanvas, $6dde447a62899039$export$2e2bcd8739ae039 as ShaderProgram, $39446e84929489b5$export$2e2bcd8739ae039 as Buffer, $36f5d74c5e4f8c80$export$2e2bcd8739ae039 as VertexBuffer, $2caa64557fc4247f$export$2e2bcd8739ae039 as ElementBuffer, $b16ed4ae54df03ae$export$2e2bcd8739ae039 as UniformBuffer, $c676ea14144bdf07$export$2e2bcd8739ae039 as VertexArray, $d097352d58eb0afd$export$2e2bcd8739ae039 as Texture};\n//# sourceMappingURL=froxel-gl.m.js.map\n","\nexport { default as WebGLCanvas } from './webgl-canvas.js';\nexport { default as ShaderProgram } from './shader-program.js';\n\nexport { default as Buffer } from './buffer.js';\nexport { default as VertexBuffer } from './vertex-buffer.js';\nexport { default as ElementBuffer } from './element-buffer.js';\nexport { default as UniformBuffer } from './uniform-buffer.js';\n\nexport { default as VertexArray } from './vertex-array.js';\nexport { default as Texture } from './texture.js';\n","\nimport ShaderProgram from './shader-program.js';\nimport VertexBuffer from './vertex-buffer.js';\nimport ElementBuffer from './element-buffer.js';\nimport VertexArray from './vertex-array.js';\nimport UniformBuffer from './uniform-buffer.js';\nimport Texture from './texture.js';\nimport Buffer from './buffer.js';\n\nimport { Mat4, Vec4 } from 'froxel-math';\n\nexport default WebGLCanvas;\n\n/**\n * @typedef {'default'|'landscape'|'portrait'|'automatic'|'strict'} WebGLCanvasOrientation\n */\n\n/**\n * @typedef {'ARRAY_BUFFER'|'ELEMENT_ARRAY_BUFFER'|'COPY_READ_BUFFER'|'COPY_WRITE_BUFFER'|'TRANSFORM_FEEDBACK_BUFFER'|'UNIFORM_BUFFER'|'PIXEL_PACK_BUFFER'|'PIXEL_UNPACK_BUFFER'} WebGLBufferTarget\n */\n\n/**\n * @typedef {'STATIC_DRAW'|'DYNAMIC_DRAW'|'STREAM_DRAW'|'STATIC_READ'|'DYNAMIC_READ'|'STREAM_READ'|'STATIC_COPY'|'DYNAMIC_COPY'|'STREAM_COPY'} WebGLBufferUsage\n */\n\n/**\n * @typedef {Object} WebGLCanvasOptions\n * @prop {boolean} [fullscreen] Positions the canvas to cover the entire screen. default `true`\n * @prop {boolean} [stencil] Indicates if the stencil buffer should be enabled. default `false`\n * @prop {string} [background] Background color, must be a 6-digit hex RGB value. default `000000`\n * @prop {number} [width] Width of the canvas, used only when `fullscreen` is `false`. default `960`\n * @prop {number} [height] Height of the canvas, used only when `fullscreen` is `false`. default `540`\n * @prop {WebGLCanvasOrientation} [orientation] Orientation of the canvas. Defaults to `AUTOMATIC`.\n * @prop {boolean} [antialias] Controls the antialias option, set to `false` for pixel-perfect output. Default is `true`.\n * @prop {number} [scaleFactorMax] Limit of the scale factor, used only when set to greater than zero.\n * @prop {number} [scaleFactorOffs] Offset used to increase the scale factor before the Math.floor operation. Default is `0.7`.\n */\n\nconst defaultOptions = {\n\tfullscreen: true,\n\tstencil: false,\n\tbackground: '000000',\n\twidth: 960,\n\theight: 540,\n\torientation: 'automatic',\n\tantialias: true,\n\tscaleFactorMax: 0,\n\tscaleFactorOffs: 0.7,\n};\n\n/**\n * List of active canvases. Registered when the WebGLCanvas is created, and removed when it is disposed.\n */\nconst activeCanvases = [\n];\n\n/**\n * Indicates if the auto-resizer has been attached to the window.\n */\nlet autoResizerAttached = false;\n\n/**\n * \n */\nfunction autoResizeCanvas (wgl)\n{\n\tlet fullWidth = wgl.options.width;\n\tlet fullHeight = wgl.options.height;\n\n\tif (wgl.options.fullscreen && ('document' in global)) {\n\t\tfullWidth = Math.floor(global.innerWidth);\n\t\tfullHeight = Math.floor(global.innerHeight);\n\t}\n\telse {\n\t\tif (wgl.options.width === null && wgl.options.height === null)\n\t\t\tthrow new Error ('At least one screen dimension must be specified in headless mode.');\n\t}\n\n\t// Flip dimensions to ensure the desired orientation.\n\tlet currentWidth = fullWidth;\n\tlet currentHeight = fullHeight;\n\tlet flipped = false;\n\n\tif ((fullWidth < fullHeight && wgl.options.orientation === 'landscape') || (fullWidth > fullHeight && wgl.options.orientation === 'portrait')) {\n\t\tcurrentWidth = fullHeight;\n\t\tcurrentHeight = fullWidth;\n\t\tflipped = true;\n\t}\n\n\t// Get target screen dimensions.\n\tlet targetWidth = wgl.options.width;\n\tlet targetHeight = wgl.options.height;\n\n\tif (targetWidth === null || targetHeight === null)\n\t{\n\t\tif (targetWidth === null && targetHeight === null) {\n\t\t\ttargetWidth = currentWidth;\n\t\t\ttargetHeight = currentHeight;\n\t\t}\n\t\telse if (targetWidth === null)\n\t\t\ttargetWidth = Math.floor(0.5 + currentWidth * (wgl.options.height / currentHeight));\n\t\telse\n\t\t\ttargetHeight = Math.floor(0.5 + currentHeight * (wgl.options.width / currentWidth));\n\t}\n\n\t// Handle `automatic` canvas orientation.\n\tlet screenWidth = targetWidth;\n\tlet screenHeight = targetHeight;\n\n\tif (wgl.options.orientation === 'automatic' && screenWidth && screenHeight)\n\t{\n\t\tif ((screenWidth > screenHeight && currentWidth < currentHeight) || (screenWidth < screenHeight && currentWidth > currentHeight)) {\n\t\t\tscreenWidth = targetHeight;\n\t\t\tscreenHeight = targetWidth;\n\t\t}\n\t}\n\n\t// Compute canvas scale factor.\n\tlet canvasScaleFactor = 1;\n\n\tif (screenWidth && screenHeight)\n\t\tcanvasScaleFactor = Math.min(currentWidth / screenWidth, currentHeight / screenHeight);\n\telse if (screenWidth)\n\t\tcanvasScaleFactor = currentWidth / screenWidth;\n\telse if (screenHeight)\n\t\tcanvasScaleFactor = currentHeight / screenHeight;\n\n\t// ***\n\tlet tmpWidth = currentWidth;\n\tlet tmpHeight = currentHeight;\n\n\tif (screenWidth) currentWidth = screenWidth;\n\tif (screenHeight) currentHeight = screenHeight;\n\n\tlet offsX = Math.floor((tmpWidth - currentWidth*canvasScaleFactor)*0.5);\n\tlet offsY = Math.floor((tmpHeight - currentHeight*canvasScaleFactor)*0.5);\n\n\tif (flipped) {\n\t\tlet tmp = offsX;\n\t\toffsX = offsY;\n\t\toffsY = tmp;\n\t}\n\n\tlet scaleFactor = canvasScaleFactor * global.devicePixelRatio;\n\tscaleFactor = Math.floor(wgl.options.scaleFactorOffs + scaleFactor);\n\n\tif (wgl.options.scaleFactorMax > 0 && scaleFactor > wgl.options.scaleFactorMax)\n\t\tscaleFactor = wgl.options.scaleFactorMax;\n\n\tif (wgl.options.fullscreen && ('document' in global))\n\t\tglobal.document.body.style.backgroundColor = wgl.element.style.backgroundColor;\n\n\twgl.resize(currentWidth, currentHeight, false);\n\n\tif (!flipped) {\n\t\twgl.element.style.width = Math.floor(currentWidth*canvasScaleFactor+0.5) + 'px';\n\t\twgl.element.style.height = Math.floor(currentHeight*canvasScaleFactor+0.5) + 'px';\n\t}\n\telse {\n\t\twgl.element.style.width = Math.floor(currentHeight*canvasScaleFactor+0.5) + 'px';\n\t\twgl.element.style.height = Math.floor(currentWidth*canvasScaleFactor+0.5) + 'px';\n\t}\n\n\twgl.element.style.marginLeft = offsX + 'px';\n\twgl.element.style.marginTop = offsY + 'px';\n\n\twgl.globalScale = scaleFactor;\n\twgl.isFlipped = flipped;\n\n\twgl.u.initial.identity();\n\twgl.u.initial.scale(scaleFactor, scaleFactor, scaleFactor);\n\n\tif (flipped) {\n\t\twgl.u.initial.rotateZ(Math.PI/2);\n\t\twgl.u.initial.translate(-currentWidth, 0, 0);\n\t}\n\n\twgl.updateViewport();\n\n\t//console.log('logical', wgl.width, wgl.height);\t\n\t//console.log('canvas-logical', wgl.element.width, wgl.element.height);\n\t//console.log('canvas-css', wgl.element.style.width, wgl.element.style.height);\n\t//console.log('phys', wgl.physWidth, wgl.physHeight);\n\t//console.log('webGl', wgl.gl.drawingBufferWidth, wgl.gl.drawingBufferHeight);\n\t//console.log('globalScale', wgl.globalScale);\n\t//console.log('canvasScaleFactor', canvasScaleFactor);\n\n\t/* *** */\n\t//if (options.maxScaleFactor > 0 && scaleFactor > options.maxScaleFactor)\n\t//\tscaleFactor = options.maxScaleFactor;\n\n\t//_this.integerScaleFactor = Math.floor(scaleFactor + 0.5); //0.9\n};\n\n\n/**\n * WebGL2 Canvas.\n *\n * Default WebGL configuration is set as follows:\n *\n * - `DEPTH_TEST`: enabled, `clearDepth`: 1.0, `depthFunc`: LEQUAL\n * - `BLEND`: enabled, `blendEquationSeparate`: FUNC_ADD, FUNC_ADD, `blendFunc`: ONE, ONE_MINUS_SRC_ALPHA\n * - `UNPACK_PREMULTIPLY_ALPHA_WEBGL`: enabled\n * - `SCISSOR_TEST`: enabled\n *\n * @extends {WebGL2RenderingContext}\n * @param {WebGLCanvasOptions} [options]\n */\nfunction WebGLCanvas (options=null)\n{\n\tif (!autoResizerAttached)\n\t{\n\t\tglobal.onresize = function() {\n\t\t\tfor (let wgl of activeCanvases) autoResizeCanvas(wgl);\n\t\t};\n\n\t\tautoResizerAttached = true;\n\t}\n\n\tthis.init({ ...defaultOptions, ...options });\n\tactiveCanvases.push(this);\n}\n\n/**\n * Disposes the canvas and all related resources.\n */\nWebGLCanvas.prototype.dispose = function()\n{\n\tactiveCanvases.splice(activeCanvases.indexOf(this), 1);\n};\n\n\n/**\n * WebGL2 rendering context.\n * @private @readonly @type {WebGL2RenderingContext}\n */\nWebGLCanvas.prototype.gl = null;\n\n/**\n * Contains the state of several WebGL elements (shader program, bound buffer, texture, etc). This is a general object, and each class or interested party\n * is responsible for accesing and maintaining values in this object.\n * @private @type {object}\n */\nWebGLCanvas.prototype.state = null;\n\n\n/**\n * @typedef {Object} WebGLCanvasUniforms\n * @prop {boolean} changed Indicates if the uniforms have changed and should be reloaded in the WebGL program.\n * @prop {Mat4} initial Transformation to achieve correct target resolution and orientation (automatically set by WebGLCanvas).\n * @prop {Mat4} view Transforms coordinates to view space.\n * @prop {Mat4} projection Transforms coordinates to NDC space. Use the `setOrtho2D`, `setOrtho3D` or `setFrustrum` methods of Utils to configure its value.\n * @prop {Vec4} resolution Canvas resolution (automatically set by WebGLCanvas).\n */\n\n/**\n * Common uniforms for WebGL. Note that it is the responsibility of the developer to set, configure and use these uniforms (except the ones marked\n * as \"automatically set by WebGLCanvas\"). Thse are provided solely as placeholders for easy access from a known interface.\n * @readonly @type {WebGLCanvasUniforms}\n */\nWebGLCanvas.prototype.u = null;\n\n/**\n * Underlying HTML5 canvas element.\n * @readonly @type {HTMLCanvasElement}\n */\nWebGLCanvas.prototype.element = null;\n\n/**\n * Logical width of the canvas.\n * @readonly @type {number}\n */\nWebGLCanvas.prototype.width = 0;\n\n/**\n * Logical height of the canvas.\n * @readonly @type {number}\n */\nWebGLCanvas.prototype.height = 0;\n\n/**\n * Physical canvas width.\n * @readonly @type {number}\n */\nWebGLCanvas.prototype.physWidth = 0;\n\n/**\n * Physical canvas height.\n * @readonly @type {number}\n */\nWebGLCanvas.prototype.physHeight = 0;\n\n/**\n * Indicates if the canvas is flipped.\n * @readonly @type {boolean}\n */\nWebGLCanvas.prototype.isFlipped = false;\n\n/**\n * Canvas global scale.\n * @readonly @type {number}\n */\nWebGLCanvas.prototype.globalScale = 1.0;\n\n/**\n * Functions that are under a different name in WebGLCanvas from the original WebGL2RenderingContext.\n */\nconst renamedFunctions = {\n\tcreateTexture: 'genTexture',\n\tcreateBuffer: 'genBuffer',\n\tcreateVertexArray: 'genVertexArray',\n};\n\n/**\n * Initializes the instance.\n * @private\n */\nWebGLCanvas.prototype.init = function (options)\n{\n\tthis.element = document.createElement('canvas');\n\tthis.options = options;\n\n\tif (!options.fullscreen && (!options.width || !options.height))\n\t\tthrow new Error ('Option `width` or `height` is missing while `fullscreen` is `false`.');\n\n\tif (options.background.length != 6)\n\t\tthrow new Error ('Option `background` should be a 6-digit hex RGB (i.e. 000000).');\n\n\tthis.element.style.imageRendering = options.antialias ? 'auto' : 'crisp-edges';\n\tthis.element.style.backgroundColor = '#' + options.background;\n\n\tif (options.fullscreen) {\n\t\tthis.element.style.position = 'absolute';\n\t\tthis.element.style.left = '0px';\n\t\tthis.element.style.top = '0px';\n\t}\n\n\t// Get WebGL context and re-bind functions and values to the WebGLCanvas object.\n\tthis.gl = this.element.getContext('webgl2', { desynchronized: false, preserveDrawingBuffer: false, alpha: false, stencil: options.stencil });\n\n\tfor (let prop in this.gl)\n\t{\n\t\tlet val = this.gl[prop];\n\t\tswitch (typeof(val))\n\t\t{\n\t\t\tcase 'function':\n\t\t\t\tif (prop in renamedFunctions)\n\t\t\t\t\tprop = renamedFunctions[prop];\n\n\t\t\t\tthis[prop] = val.bind(this.gl);\n\t\t\t\tbreak;\n\n\t\t\tcase 'number':\n\t\t\t\tthis[prop] = val;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tconsole.log(this.getParameter(this.VERSION) + ', ' + this.getParameter(this.SHADING_LANGUAGE_VERSION));\n\n\t// Global state object.\n\tthis.state =\n\t{\n\t\tprogram: null,\n\t\tbuffer: { },\n\t\tvertexArray:  null\n\t};\n\n\t// Allocate placeholder for uniforms.\n\tthis.u = {\n\t\tchanged: true,\n\n\t\tinitial: Mat4.alloc(),\n\t\tview: Mat4.alloc(),\n\t\tprojection: Mat4.alloc(),\n\t\tresolution: Vec4.alloc(),\n\t};\n\n\t// Initialize default configuration.\n\tthis.clearColor (parseInt(options.background.substring(0,2), 16)/255.0, parseInt(options.background.substring(2,4), 16)/255.0, parseInt(options.background.substring(4,6), 16)/255.0, 1.0);\n\tthis.colorMask (true, true, true, true);\n\n\tthis.enable (this.DEPTH_TEST);\n\tthis.clearDepth (1.0);\n\tthis.depthFunc (this.LEQUAL);\n\n\tthis.enable (this.BLEND);\n\tthis.pixelStorei (this.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n\tthis.blendEquationSeparate (this.FUNC_ADD, this.FUNC_ADD);\n\tthis.blendFunc (this.ONE, this.ONE_MINUS_SRC_ALPHA);\n\n\tthis.enable (this.SCISSOR_TEST);\n\tautoResizeCanvas(this);\n};\n\n\n/**\n * Resizes the canvas to the specified logical size.\n * @param {number} width\n * @param {number} height\n */\nWebGLCanvas.prototype.resize = function (width, height, updateViewport=true)\n{\n\tthis.width = width;\n\tthis.height = height;\n\n\tif (updateViewport)\n\t\tthis.updateViewport();\n};\n\n// VIOLET: Possibly create a viewport object like the olden days.\nWebGLCanvas.prototype.updateViewport = function ()\n{\n\tthis.physWidth = this.element.width = Math.floor((this.isFlipped ? this.height : this.width) * this.globalScale);\n\tthis.physHeight = this.element.height = Math.floor((this.isFlipped ? this.width : this.height) * this.globalScale);\n\n\tthis.scissor (0, 0, this.physWidth, this.physHeight);\n\tthis.viewport (0, 0, this.physWidth, this.physHeight);\n\n\t//violet:hardware scaling? currently we're using canvas browser-level scaling.\n\t//this.v_resolution[0] = this._width;\n\t//this.v_resolution[1] = this._height;\n\tthis.u.resolution.set(this.physWidth, this.physHeight, this.isFlipped ? this.physHeight : this.physWidth, this.isFlipped ? this.physWidth : this.physHeight);\n\tthis.u.changed = true;\n};\n\n\n/**\n * Creates a shader program with the specified vertex and fragment shader source codes.\n * @param {string} vertexShaderSource\n * @param {string} fragmentShaderSource\n * @param {string} geometryShaderSource?\n * @returns {ShaderProgram}\n */\nWebGLCanvas.prototype.createShaderProgram = function (vertexShaderSource, fragmentShaderSource, geometryShaderSource=null) {\n\treturn new ShaderProgram(this, vertexShaderSource, fragmentShaderSource, geometryShaderSource);\n};\n\n\n/**\n * Creates a new vertex array object.\n * @returns {VertexArray}\n */\nWebGLCanvas.prototype.createVertexArray = function () {\n\treturn new VertexArray(this);\n};\n\n\n/**\n * Creates a new buffer.\n * @param {WebGLBufferTarget} target\n * @param {WebGLBufferUsage} usage\n * @returns {VertexBuffer}\n */\nWebGLCanvas.prototype.createBuffer = function (target, usage) {\n\treturn new Buffer(this, this[target], this[usage]);\n};\n\n\n/**\n * Creates a new vertex buffer.\n * @param {WebGLBufferUsage} usage\n * @returns {VertexBuffer}\n */\nWebGLCanvas.prototype.createVertexBuffer = function (usage) {\n\treturn new VertexBuffer(this, this[usage]);\n};\n\n\n/**\n * Creates a new element buffer.\n * @param {WebGLBufferUsage} usage\n * @returns {ElementBuffer}\n */\nWebGLCanvas.prototype.createElementBuffer = function (usage) {\n\treturn new ElementBuffer(this, this[usage]);\n};\n\n\n/**\n * Creates a new uniform buffer object.\n * @param {WebGLBufferUsage} usage\n * @returns {UniformBuffer}\n */\nWebGLCanvas.prototype.createUniformBuffer = function (usage) {\n\treturn new UniformBuffer(this, this[usage]);\n};\n\n\n/**\n * Creates a new texture object of the specified size.\n * @param {number} width - Physical texture width.\n * @param {number} height - Physical texture height.\n * @param {number} [targetWidth] - Logical texture width.\n * @param {number} [targetHeight] - Logical texture height.\n * @returns {Texture}\n */\nWebGLCanvas.prototype.createTexture = function (width, height, targetWidth=null, targetHeight=null) {\n\treturn new Texture (this, width, height, targetWidth, targetHeight);\n};\n\n\n/**\n * Loads an image from the specified URL.\n * @param {string} url\n * @returns {Promise<HTMLImageElement>}\n */\nWebGLCanvas.loadImage = function (url)\n{\n\treturn new Promise((resolve, reject) => {\n\t\tlet img = new Image();\n\t\timg.onload = () => resolve(img);\n\t\timg.onerror = () => reject('Unable to load image: ' + url);\n\t\timg.src = url;\n\t});\n};\n\n\n/**\n * Loads an image from the specified URL and creates a texture.\n * @param {string} url\n * @param {number} [mipmapLevels] - Number of levels for mipmapping. Defaults to `0`.\n * @returns {Promise<Texture>}\n */\nWebGLCanvas.prototype.loadTextureFromUrl = async function (url, mipmapLevels=0)\n{\n\tlet image = await WebGLCanvas.loadImage(url);\n\tlet texture = this.createTexture(image.width, image.height);\n\ttexture.setMipmapLevels(mipmapLevels);\n\ttexture.upload(image);\n\treturn texture;\n};\n","\nimport WebGLCanvas from './webgl-canvas.js';\nimport UniformBuffer from './uniform-buffer.js';\n\n/**\n * Describes a WebGL shader program.\n */\nexport default class ShaderProgram\n{\n\t/**\n\t * Reference to the WebGLCanvas.\n\t * @readonly @type {WebGLCanvas}\n\t */\n\tgl;\n\n\t/**\n\t * Vertex shader resource object.\n\t * @private @type {WebGLShader}\n\t */\n\tvertexShader;\n\n\t/**\n\t * Fragment shader resource object.\n\t * @private @type {WebGLShader}\n\t */\n\tfragmentShader;\n\n\t/**\n\t * Fragment shader resource object.\n\t * @private @type {WebGLShader}\n\t */\n\tgeometryShader;\n\n\t/**\n\t * Shader program resource object.\n\t * @readonly @type {WebGLProgram}\n\t */\n\tprogram;\n\n\t/**\n\t * Uniform and uniform block cache.\n\t * @private @type {object}\n\t */\n\tcache;\n\n\t/**\n\t * Creates a WebGL GLSL Shader Program.\n\t * @param {WebGLCanvas} gl\n\t * @param {string} vertexShaderSource\n\t * @param {string} fragmentShaderSource\n\t * @param {string} geometryShaderSource?\n\t */\n\tconstructor (gl, vertexShaderSource, fragmentShaderSource, geometryShaderSource=null)\n\t{\n\t\tthis.gl = gl;\n\n\t\t/* *** */\n\t\tif (!vertexShaderSource.startsWith('#version'))\n\t\t\tvertexShaderSource = '#version 300 es\\nprecision highp float;\\n' + vertexShaderSource;\n\n\t\tthis.vertexShader = gl.createShader(gl.VERTEX_SHADER);\n\t\tgl.shaderSource(this.vertexShader, vertexShaderSource);\n\t\tgl.compileShader(this.vertexShader);\n\n\t\t/* *** */\n\t\tif (!fragmentShaderSource.startsWith('#version'))\n\t\t\tfragmentShaderSource = '#version 300 es\\nprecision highp float;\\n' + fragmentShaderSource;\n\n\t\tthis.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n\t\tgl.shaderSource(this.fragmentShader, fragmentShaderSource);\n\t\tgl.compileShader(this.fragmentShader);\n\n\t\t/* *** */\n\t\tif (geometryShaderSource !== null)\n\t\t{\n\t\t\tif (!geometryShaderSource.startsWith('#version'))\n\t\t\t\tgeometryShaderSource = '#version 300 es\\nprecision highp float;\\n' + geometryShaderSource;\n\n\t\t\tthis.geometryShader = gl.createShader(gl.GEOMETRY_SHADER);\n\t\t\tgl.shaderSource(this.geometryShader, geometryShaderSource);\n\t\t\tgl.compileShader(this.geometryShader);\n\t\t}\n\t\telse\n\t\t\tthis.geometryShader = null;\n\n\t\t/* *** */\n\t\tthis.program = gl.createProgram();\n\n\t\tgl.attachShader(this.program, this.vertexShader);\n\t\tgl.attachShader(this.program, this.fragmentShader);\n\n\t\tif (this.geometryShader)\n\t\t\tgl.attachShader(this.program, this.geometryShader);\n\n\t\tthis.cache = { u: { }, b: { }, a: { } };\n\t\tthis.linkProgram();\n\t}\n\n\t/**\n\t * Map of global attribute locations.\n\t * @readonly @private\n\t * @type {Map<string, number>}\n\t */\n\tstatic attribLocations = new Map();\n\n\t/**\n\t * Binds a global attribute location to be applied to any newly created shader program.\n\t * @param {number} attribLocation\n\t * @param {string} attribName\n\t */\n\tstatic bindAttribLocation (attribLocation, attribName)\n\t{\n\t\tif (typeof attribLocation === 'string')\n\t\t\tthrow new Error('bindAttribLocation: attribLocation should be a number');\n\n\t\tShaderProgram.attribLocations[attribName] = attribLocation;\n\t}\n\n\t/**\n\t * Binds several global attribute locations to be applied to any newly created shader program.\n\t * @param {Map<string, number>} attribs\n\t */\n\tstatic bindAttribLocations (attribs)\n\t{\n\t\tfor (let attribName in attribs)\n\t\t\tShaderProgram.attribLocations[attribName] = attribs[attribName];\n\t}\n\n\t/**\n\t * Links the program and throws an error if there was any problem.\n\t * @private\n\t * @throws {Error}\n\t * @returns {ShaderProgram}\n\t */\n\tlinkProgram()\n\t{\n\t\tfor (let attribName in ShaderProgram.attribLocations)\n\t\t\tthis.gl.bindAttribLocation(this.program, ShaderProgram.attribLocations[attribName], attribName);\n\n\t\tthis.gl.linkProgram (this.program);\n\t\tif (this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS))\n\t\t{\n\t\t\tthis.gl.deleteShader(this.vertexShader)\n\t\t\tthis.gl.deleteShader(this.fragmentShader)\n\n\t\t\tif (this.geometryShader)\n\t\t\t\tthis.gl.deleteShader(this.geometryShader);\n\n\t\t\treturn this;\n\t\t}\n\n\t\tlet vertexError = this.gl.getShaderInfoLog(this.vertexShader);\n\t\tlet fragmentError = this.gl.getShaderInfoLog(this.fragmentShader);\n\t\tlet geometryError = this.geometryShader ? this.gl.getShaderInfoLog(this.geometryShader) : '';\n\n\t\tthrow new Error(\n\t\t\tvertexError ? ('• Vertex Shader:\\n' + vertexError + '\\n') : '' +\n\t\t\tgeometryError ? ('• Geometry Shader:\\n' + geometryError + '\\n') : '' + \n\t\t\tfragmentError ? ('• Fragment Shader:\\n' + fragmentError) : ''\n\t\t);\n\t}\n\n\t/**\n\t * Binds an attribute location to the shader program.\n\t * @param {number} attribLocation\n\t * @param {string} attribName\n\t * @returns {ShaderProgram}\n\t */\n\tbindAttribLocation (attribLocation, attribName)\n\t{\n\t\tthis.gl.bindAttribLocation(this.program, attribLocation, attribName);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the location of an attribute.\n\t * @param {string} attribName\n\t * @returns {WebGLUniformLocation}\n\t */\n\tgetAttribLocation (attribName)\n\t{\n\t\tif (!(attribName in this.cache.u))\n\t\t\tthis.cache.a[attribName] = this.gl.getAttribLocation(this.program, attribName);\n\n\t\treturn this.cache.a[attribName];\n\t}\n\n\t/**\n\t * Returns the location of one or more attributes.\n\t * @param {Array<string>} attribNames\n\t * @returns { [key: string]: WebGLUniformLocation }\n\t */\n\tgetAttribLocations (attribNames)\n\t{\n\t\tlet attribs = { };\n\n\t\tfor (let uniformName of attribNames) {\n\t\t\tattribs[uniformName] = this.getAttribLocation(uniformName);\n\t\t}\n\n\t\treturn attribs;\n\t}\n\n\t/**\n\t * Activates the shader program for subsequent drawing operations.\n\t * @returns {ShaderProgram}\n\t */\n\tuseProgram()\n\t{\n\t\tif (this.gl.state.program === this)\n\t\t\treturn this;\n\n\t\tthis.gl.useProgram(this.program);\n\t\tthis.gl.state.program = this;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the location of a uniform variable.\n\t * @param {string} uniformName\n\t * @returns {WebGLUniformLocation}\n\t */\n\tgetUniformLocation (uniformName)\n\t{\n\t\tif (!(uniformName in this.cache.u))\n\t\t\tthis.cache.u[uniformName] = this.gl.getUniformLocation(this.program, uniformName);\n\n\t\treturn this.cache.u[uniformName];\n\t}\n\n\t/**\n\t * Returns the location of one or more uniform variables.\n\t * @param {Array<string>} uniformNames\n\t * @returns { [key: string]: WebGLUniformLocation }\n\t */\n\tgetUniformLocations (uniformNames)\n\t{\n\t\tlet uniforms = { };\n\n\t\tfor (let uniformName of uniformNames) {\n\t\t\tuniforms[uniformName] = this.getUniformLocation(uniformName);\n\t\t}\n\n\t\treturn uniforms;\n\t}\n\n\t/**\n\t * Returns the index and offset of one or more uniform variables. Highly useful to build an appropriate uniform buffer object (UBO) when\n\t * the exact layout of the data is not known beforehand (but the uniform names are).\n\t * @param {Array<string>} uniformNames\n\t * @returns { [key: string]: { index: number, offset: number } }\n\t */\n\tgetUniformOffsets (uniformNames)\n\t{\n\t\tlet uniforms = { };\n\n\t\tlet indices = this.gl.getUniformIndices(this.program, uniformNames);\n\t\tlet offsets = this.gl.getActiveUniforms(this.program, indices, this.gl.UNIFORM_OFFSET);\n\n\t\tfor (let i in uniformNames) {\n\t\t\tuniforms[uniformNames[i]] = { index: indices[i], offset: offsets[i] };\n\t\t}\n\n\t\treturn uniforms;\n\t}\n\n\t/**\n\t * Returns the index of a uniform block.\n\t * @param {string} blockName\n\t * @returns {number}\n\t */\n\tgetUniformBlockIndex (blockName)\n\t{\n\t\tif (!(blockName in this.cache.b))\n\t\t\tthis.cache.b[blockName] = this.gl.getUniformBlockIndex(this.program, blockName);\n\n\t\treturn this.cache.b[blockName];\n\t}\n\n\t/**\n\t * Returns the indices of one or more uniform blocks.\n\t * @param {Array<string>} blockNames\n\t * @returns { [key: string]: number }\n\t */\n\tgetUniformBlockIndices (blockNames)\n\t{\n\t\tlet indices = { };\n\n\t\tfor (let blockName of blockNames) {\n\t\t\tindices[blockName] = this.getUniformBlockIndex(blockName);\n\t\t}\n\n\t\treturn indices;\n\t}\n\n\t/**\n\t * Binds a uniform buffer to a uniform block in the program.\n\t * @param {number|string} blockIdentifier\n\t * @param {number|UniformBuffer} bindingIndex\n\t * @returns {ShaderProgram}\n\t */\n\tbindUniformBlock (blockIdentifier, bindingIndex)\n\t{\n\t\tif (typeof(blockIdentifier) === 'string')\n\t\t\tblockIdentifier = this.getUniformBlockIndex(blockIdentifier);\n\n\t\tif (bindingIndex instanceof UniformBuffer)\n\t\t\tbindingIndex = bindingIndex.bindingIndex;\n\n\t\treturn this.gl.uniformBlockBinding (this.program, blockIdentifier, bindingIndex);\n\t}\n};\n","\nimport WebGLCanvas from './webgl-canvas.js';\nimport Buffer from './buffer.js';\n\nexport default class UniformBuffer extends Buffer\n{\n\t/**\n\t * Uniform block binding index. Set using `bindBufferBase`.\n\t * @readonly @type {number}\n\t */\n\tbindingIndex;\n\n\t/**\n\t * Creates a buffer for the UNIFORM_BUFFER target.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} usage\n\t */\n\tconstructor (gl, usage)\n\t{\n\t\tsuper (gl, gl.UNIFORM_BUFFER, usage);\n\t}\n\n\t/**\n\t * Binds the buffer to given index of the UNIFORM_BUFFER binding point.\n\t * @param {number} index\n\t * @returns {UniformBuffer}\n\t */\n\tbufferIndex (index)\n\t{\n\t\t this.gl.bindBufferBase(this.target, this.bindingIndex=index, this.buffer);\n\t\t return this;\n\t}\n};\n","\nimport WebGLCanvas from './webgl-canvas.js';\n\n/**\n * Represents a WebGL buffer.\n */\nexport default class Buffer\n{\n\t/**\n\t * Reference to the WebGLCanvas.\n\t * @readonly @type {WebGLCanvas}\n\t */\n\tgl;\n\n\t/**\n\t * Buffer target.\n\t * @readonly @type {number}\n\t */\n\ttarget;\n\n\t/**\n\t * Buffer usage mode.\n\t * @readonly @type {number}\n\t */\n\tusage;\n\n\t/**\n\t * Buffer object resource.\n\t * @readonly @type {WebGLBuffer}\n\t */\n\tbuffer;\n\n\t/**\n\t * Buffer size in bytes.\n\t * @readonly @type {number}\n\t */\n\tbyteLength;\n\n\t/**\n\t * Source buffer, used for automatic upload of data to the GPU memory when `update` is called.\n\t * @readonly @type {Uint8Array}\n\t */\n\tsource;\n\n\t/**\n\t * Creates a WebGL buffer.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} target\n\t * @param {number} usage\n\t */\n\tconstructor (gl, target, usage)\n\t{\n\t\tthis.gl = gl;\n\t\tthis.target = target;\n\t\tthis.usage = usage;\n\n\t\tthis.buffer = gl.genBuffer();\n\t\tthis.byteLength = null;\n\n\t\tthis.source = null;\n\t}\n\n\t/**\n\t * Binds the buffer to its respective WebGL target.\n\t * @returns {Buffer}\n\t */\n\tbindBuffer()\n\t{\n\t\tif (this.gl.state.buffer[this.target] === this)\n\t\t\treturn this;\n\n\t\tthis.gl.bindBuffer(this.target, this.buffer);\n\t\tthis.gl.state.buffer[this.target] = this;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unbinds the buffer from its GPU buffer target.\n\t * @returns {Buffer}\n\t */\n\tunbindBuffer()\n\t{\n\t\tthis.gl.bindBuffer(this.target, null);\n\t\tthis.gl.state.buffer[this.target] = null;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Allocates the specified number of bytes for the buffer.\n\t * @param {number} numBytes\n\t * @returns {Buffer}\n\t */\n\tallocate (numBytes)\n\t{\n\t\tthis.bindBuffer();\n\t\tthis.gl.bufferData(this.target, numBytes, this.usage);\n\t\tthis.byteLength = numBytes;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Initializes and creates the buffer object's data store.\n\t * @param {ArrayBufferView} srcData\n\t * @param {number} srcOffset?\n\t * @returns {Buffer}\n\t */\n\tbufferData (srcData, srcOffset=0)\n\t{\n\t\tthis.bindBuffer();\n\t\tthis.gl.bufferData(this.target, srcData, this.usage, srcOffset);\n\t\tthis.byteLength = this.gl.getBufferParameter(this.target, this.gl.BUFFER_SIZE);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Updates a subset of the buffer object's data store. \n\t * @param {number} dstByteOffset\n\t * @param {ArrayBufferView} srcData\n\t * @param {number} srcOffset?\n\t * @param {number} length?\n\t * @returns {Buffer}\n\t */\n\tbufferSubData (dstByteOffset, srcData, srcOffset=0, length=0)\n\t{\n\t\tthis.bindBuffer();\n\t\tthis.gl.bufferSubData(this.target, dstByteOffset, srcData, srcOffset, length ? length : srcData.length);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Deletes the buffer.\n\t */\n\tdeleteBuffer()\n\t{\n\t\tthis.gl.deleteBuffer(this.buffer);\n\t}\n\n\t/**\n\t * Sets the buffer source. When not `null`, calling `update` will automatically upload the source buffer's data to the GPU.\n\t * @param {Uint8Array} buffer\n\t * @returns {Buffer}\n\t */\n\tbufferSource (buffer)\n\t{\n\t\tif (this.byteLength === null)\n\t\t\tthis.bufferData(buffer);\n\n\t\tthis.source = buffer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Updates the buffer in the GPU with data from the source buffer (only when not `null`).\n\t * @param {number} byteOffset\n\t * @param {number} byteLength\n\t * @returns {Buffer}\n\t */\n\tupdate (byteOffset=0, byteLength=0)\n\t{\n\t\tif (this.source !== null)\n\t\t\tthis.bufferSubData(byteOffset, this.source, byteOffset, byteLength);\n\n\t\treturn this;\n\t}\n};\n","\nimport WebGLCanvas from './webgl-canvas.js';\nimport Buffer from './buffer.js';\n\n/**\n * @typedef {'BYTE'|'UNSIGNED_BYTE'|'SHORT'|'UNSIGNED_SHORT'|'FLOAT'} WebGLAttribType\n */\n\nexport default class VertexBuffer extends Buffer\n{\n\t/**\n\t * Stride of the buffer.\n\t * @readonly @type {number}\n\t */\n\tstride;\n\n\t/**\n\t * Creates a buffer for the ARRAY_BUFFER target.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} usage\n\t */\n\tconstructor (gl, usage)\n\t{\n\t\tsuper (gl, gl.ARRAY_BUFFER, usage);\n\t}\n\n\t/**\n\t * Sets the stride of the vertex buffer.\n\t * @param {number} stride\n\t * @returns {VertexBuffer}\n\t */\n\tbufferStride (stride)\n\t{\n\t\tthis.stride = stride;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Configures a vertex attribute pointer.\n\t * @param {number} attribLocation - Location of the attribute within the shader program.\n\t * @param {number} dataSize - Number of bytes for this attribute.\n\t * @param {WebGLAttribType} dataType - Type of the attribute.\n\t * @param {number} byteOffset - Offset within the buffer to the first value.\n\t * @returns {VertexBuffer}\n\t */\n\tattribPointer (attribLocation, dataSize, dataType, byteOffset=0)\n\t{\n\t\tthis.bindBuffer();\n\t\tthis.gl.vertexAttribPointer(attribLocation, dataSize, this.gl[dataType], false, this.stride, byteOffset);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Enables the attribute vertex array at the specified location.\n\t * @param {number} attribLocation \n\t * @returns {VertexBuffer}\n\t */\n\tenableAttrib (attribLocation)\n\t{\n\t\tthis.bindBuffer();\n\t\tthis.gl.enableVertexAttribArray(attribLocation);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Disables the attribute vertex array at the specified location.\n\t * @param {number} attribLocation\n\t * @returns {VertexBuffer}\n\t */\n\tdisableAttrib (attribLocation)\n\t{\n\t\tthis.bindBuffer();\n\t\tthis.gl.disableVertexAttribArray(attribLocation);\n\t\treturn this;\n\t}\n};\n","\nimport WebGLCanvas from './webgl-canvas.js';\nimport Buffer from './buffer.js';\n\nexport default class ElementBuffer extends Buffer\n{\n\t/**\n\t * Creates a buffer for the ELEMENT_ARRAY_BUFFER target.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} usage\n\t */\n\tconstructor (gl, usage)\n\t{\n\t\tsuper (gl, gl.ELEMENT_ARRAY_BUFFER, usage);\n\t}\n};\n","\nimport WebGLCanvas from './webgl-canvas.js';\n\nexport default VertexArray;\n\n/**\n * Vertex Array Object (VAO) is a data structure that stores information about an associated element buffer, one or more vertex attribute\n * pointers, and also one or more vertex buffers.\n * @param {WebGLCanvas} gl\n */\nfunction VertexArray (gl)\n{\n\t/**\n\t * Reference to the WebGLCanvas.\n\t * @readonly @type {WebGLCanvas}\n\t */\n\tthis.gl = gl;\n\n\t/**\n\t * Vertex array object resource.\n\t * @type {WebGLVertexArrayObject}\n\t */\n\tthis.vertexArray = gl.genVertexArray();\n};\n\n/**\n * Binds the vertex array object to the GPU.\n * @returns {VertexArray}\n */\nVertexArray.prototype.bindVertexArray = function()\n{\n\tif (this.gl.state.vertexArray === this)\n\t\treturn this;\n\n\tthis.gl.bindVertexArray(this.vertexArray);\n\tthis.gl.state.vertexArray = this;\n\treturn this;\n};\n\n/**\n * Unbinds the vertex array object from the GPU.\n * @returns {VertexArray}\n */\nVertexArray.prototype.unbindVertexArray = function()\n{\n\tthis.gl.bindVertexArray(null);\n\tthis.gl.state.vertexArray = null;\n\treturn this;\n};\n","\nimport WebGLCanvas from './webgl-canvas.js';\n\n/**\n * @typedef {'NEAREST'|'LINEAR'} TextureFilterType\n */\n/**\n * @typedef {'REPEAT'|'CLAMP_TO_EDGE'|'MIRRORED_REPEAT'} TextureWrapMode\n */\n\n/**\n * WebGLCanvas Texture Object.\n */\nexport default class Texture\n{\n\t/**\n\t * Reference to the WebGLCanvas.\n\t * @readonly @type {WebGLCanvas}\n\t */\n\tgl;\n\n\t/**\n\t * Texture object resource.\n\t * @readonly @type {WebGLTexture}\n\t */\n\ttexture;\n\n\t/**\n\t * Texture width (physical width).\n\t * @readonly @type {number}\n\t */\n\twidth;\n\n\t/**\n\t * Texture height (physical height).\n\t * @readonly @type {number}\n\t */\n\theight;\n\n\t/**\n\t * Target width originally requested (logical width).\n\t * @readonly @type {number}\n\t */\n\ttargetWidth;\n\n\t/**\n\t * Target height originally requested (logical height).\n\t * @readonly @type {number}\n\t */\n\ttargetHeight;\n\n\t/**\n\t * Scale of the texture (physical width / logical width).\n\t * @readonly @type {number}\n\t */\n\tscale;\n\n\t/**\n\t * Texture filter type. Defaults to `LINEAR`.\n\t * @readonly @type {TextureFilterType}\n\t */\n\tfilterType;\n\n\t/**\n\t * Texture wrap mode. Defaults to `CLAMP_TO_EDGE`.\n\t * @readonly @type {TextureWrapMode}\n\t */\n\twrapMode;\n\n\t/**\n\t * Number of mipmap levels (use 0 to disable). Default is `0`.\n\t * @readonly @type {number}\n\t */\n\tmipmapLevels;\n\n\t/**\n\t * Indicates if the texture storage has already been allocated.\n\t * @readonly @private @type {boolean}\n\t */\n\tallocated;\n\n\t/**\n\t * Creates an empty texture object of the specified size.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} width - Physical texture width.\n\t * @param {number} height - Physical texture height.\n\t * @param {number} [targetWidth] - Logical texture width.\n\t * @param {number} [targetHeight] - Logical texture height.\n\t */\n\tconstructor (gl, width, height, targetWidth=null, targetHeight=null)\n\t{\n\t\tthis.gl = gl;\n\t\tthis.texture = gl.genTexture();\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.targetWidth = targetWidth ?? width;\n\t\tthis.targetHeight = targetHeight ?? height;\n\t\tthis.scale = this.width / this.targetWidth;\n\n\t\tthis.allocated = false;\n\t\tthis.mipmapLevels = 0;\n\t\tthis.wrapMode = 'CLAMP_TO_EDGE';\n\t\tthis.filterType = 'LINEAR';\n\t}\n\n\t/**\n\t * Binds the texture to the `TEXTURE_2D` target and allocates the texture storage if not allocated yet.\n\t * @returns {Texture}\n\t */\n\tbindTexture()\n\t{\n\t\tthis.gl.bindTexture (this.gl.TEXTURE_2D, this.texture);\n\t\tif (this.allocated !== false) return this;\n\n\t\tthis.allocated = null;\n\t\tthis.allocate();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Allocates the texture storage.\n\t * @returns {Texture}\n\t */\n\tallocate()\n\t{\n\t\tif (this.allocated === true)\n\t\t\treturn this;\n\n\t\tthis.allocated = true;\n\t\tthis.bindTexture().applyFilter().applyWrap();\n\n\t\tif (this.mipmapLevels > 0)\n\t\t\tthis.gl.texStorage2D(this.gl.TEXTURE_2D, this.mipmapLevels, this.gl.RGBA8, this.width, this.height);\n\t\telse\n\t\t\tthis.gl.texStorage2D(this.gl.TEXTURE_2D, 1, this.gl.RGBA8, this.width, this.height);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Applies the texture filter.\n\t * @private\n\t * @param {boolean} [bindTexture]\n\t * @returns {Texture}\n\t */\n\tapplyFilter (bindTexture=false)\n\t{\n\t\tif (bindTexture) this.bindTexture();\n\n\t\tlet minFilter = this.gl.LINEAR;\n\t\tlet magFilter = this.gl.LINEAR;\n\n\t\tif (this.filterType === 'NEAREST')\n\t\t\tminFilter = magFilter = this.gl.NEAREST;\n\n\t\tif (this.mipmapLevels > 0)\n\t\t{\n\t\t\tminFilter = this.gl.LINEAR_MIPMAP_LINEAR\n\n\t\t\tif (this.filterType === 'NEAREST')\n\t\t\t\tminFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n\t\t}\n\n\t\tthis.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, minFilter);\n\t\tthis.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, magFilter);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Applies the texture wrap mode.\n\t * @private\n\t * @param {boolean} [bindTexture]\n\t * @returns {Texture}\n\t */\n\tapplyWrap (bindTexture=false)\n\t{\n\t\tif (bindTexture) this.bindTexture();\n\n\t\tlet wrapMode = this.gl.CLAMP_TO_EDGE;\n\n\t\tif (this.wrapMode === 'REPEAT')\n\t\t\twrapMode = this.gl.REPEAT;\n\t\telse if (this.wrap === 'MIRRORED_REPEAT')\n\t\t\twrapMode = this.gl.MIRRORED_REPEAT;\n\n\t\tthis.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, wrapMode);\n\t\tthis.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, wrapMode);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the texture filter type.\n\t * @param {TextureFilterType} filterType\n\t * @returns {Texture}\n\t */\n\tsetFilter (filterType)\n\t{\n\t\tthis.filterType = filterType;\n\t\treturn this.allocated === true ? this.applyFilter(true) : this;\n\t}\n\n\t/**\n\t * Sets the texture wrap mode.\n\t * @param {TextureWrapMode} wrapMode\n\t * @returns {Texture}\n\t */\n\tsetWrapMode (wrapMode)\n\t{\n\t\tthis.wrapMode = wrapMode;\n\t\treturn this.allocated === true ? this.applyWrap(true) : this;\n\t}\n\n\t/**\n\t * Sets the number of mipmap levels. Valid only if texture data has not been allocated yet.\n\t * @param {number} numLevels\n\t * @returns {Texture}\n\t */\n\tsetMipmapLevels (numLevels)\n\t{\n\t\tif (this.allocated === true)\n\t\t\treturn this;\n\n\t\tthis.mipmapLevels = Math.max(0, numLevels);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Uploads data to the GPU from the specified image.\n\t * @param {HTMLImageElement} image\n\t * @param {number} [offsX] - Target X offset.\n\t * @param {number} [offsY] - Target Y offset;\n\t * @returns {Texture}\n\t */\n\tupload (image, offsX=0, offsY=0)\n\t{\n\t\tthis.bindTexture();\n\t\tthis.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, offsX, offsY, Math.min(image.width, this.width), Math.min(image.height, this.height), this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\n\n\t\tif (this.mipmapLevels > 0)\n\t\t\tthis.gl.generateMipmap(this.gl.TEXTURE_2D);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Makes the texture active on the specified texture unit.\n\t * @param {number} unit - Texture unit index (0 to 15).\n\t * @returns {Texture}\n\t */\n\tactiveTexture (unit)\n\t{\n\t\tthis.gl.activeTexture(this.gl.TEXTURE0+(unit&15));\n\t\tthis.bindTexture();\n\t\treturn this;\n\t}\n};\n"],"names":["Mat4","$dvKFe$Mat4","Vec4","$dvKFe$Vec4","$parcel$global","globalThis","self","window","global","$39446e84929489b5$export$2e2bcd8739ae039","gl","target","usage","buffer","byteLength","source","constructor","genBuffer","bindBuffer","state","unbindBuffer","allocate","numBytes","bufferData","srcData","srcOffset","getBufferParameter","BUFFER_SIZE","bufferSubData","dstByteOffset","length","deleteBuffer","bufferSource","update","byteOffset","$b16ed4ae54df03ae$export$2e2bcd8739ae039","bindingIndex","UNIFORM_BUFFER","bufferIndex","index","bindBufferBase","$6dde447a62899039$export$2e2bcd8739ae039","vertexShader","fragmentShader","geometryShader","program","cache","vertexShaderSource","fragmentShaderSource","geometryShaderSource","startsWith","createShader","VERTEX_SHADER","shaderSource","compileShader","FRAGMENT_SHADER","GEOMETRY_SHADER","createProgram","attachShader","u","b","a","linkProgram","attribLocations","Map","bindAttribLocation","attribLocation","attribName","Error","bindAttribLocations","attribs","getProgramParameter","LINK_STATUS","deleteShader","vertexError","getShaderInfoLog","fragmentError","geometryError","getAttribLocation","getAttribLocations","attribNames","uniformName","useProgram","getUniformLocation","getUniformLocations","uniformNames","uniforms","getUniformOffsets","indices","getUniformIndices","offsets","getActiveUniforms","UNIFORM_OFFSET","i","offset","getUniformBlockIndex","blockName","getUniformBlockIndices","blockNames","bindUniformBlock","blockIdentifier","uniformBlockBinding","$36f5d74c5e4f8c80$export$2e2bcd8739ae039","stride","ARRAY_BUFFER","bufferStride","attribPointer","dataSize","dataType","vertexAttribPointer","enableAttrib","enableVertexAttribArray","disableAttrib","disableVertexAttribArray","$2caa64557fc4247f$export$2e2bcd8739ae039","ELEMENT_ARRAY_BUFFER","$c676ea14144bdf07$export$2e2bcd8739ae039","$c676ea14144bdf07$var$VertexArray","vertexArray","genVertexArray","prototype","bindVertexArray","unbindVertexArray","$d097352d58eb0afd$export$2e2bcd8739ae039","texture","width","height","targetWidth","targetHeight","scale","filterType","wrapMode","mipmapLevels","allocated","genTexture","bindTexture","TEXTURE_2D","applyFilter","applyWrap","texStorage2D","RGBA8","minFilter","LINEAR","magFilter","NEAREST","LINEAR_MIPMAP_LINEAR","NEAREST_MIPMAP_LINEAR","texParameteri","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","CLAMP_TO_EDGE","REPEAT","wrap","MIRRORED_REPEAT","TEXTURE_WRAP_S","TEXTURE_WRAP_T","setFilter","setWrapMode","setMipmapLevels","numLevels","Math","max","upload","image","offsX","offsY","texSubImage2D","min","RGBA","UNSIGNED_BYTE","generateMipmap","activeTexture","unit","TEXTURE0","$e3e474f4ae65cf0e$export$2e2bcd8739ae039","$e3e474f4ae65cf0e$var$WebGLCanvas","$e3e474f4ae65cf0e$var$defaultOptions","fullscreen","stencil","background","orientation","antialias","scaleFactorMax","scaleFactorOffs","$e3e474f4ae65cf0e$var$activeCanvases","$e3e474f4ae65cf0e$var$autoResizerAttached","$e3e474f4ae65cf0e$var$autoResizeCanvas","wgl","fullWidth","options","fullHeight","floor","innerWidth","innerHeight","currentWidth","currentHeight","flipped","screenWidth","screenHeight","canvasScaleFactor","tmpWidth","tmpHeight","tmp","scaleFactor","devicePixelRatio","document","body","style","backgroundColor","element","resize","marginLeft","marginTop","globalScale","isFlipped","initial","identity","rotateZ","PI","translate","updateViewport","onresize","init","push","dispose","splice","indexOf","physWidth","physHeight","$e3e474f4ae65cf0e$var$renamedFunctions","createTexture","createBuffer","createVertexArray","createElement","prop","imageRendering","position","left","top","getContext","desynchronized","preserveDrawingBuffer","alpha","val","bind","console","log","getParameter","VERSION","SHADING_LANGUAGE_VERSION","changed","alloc","view","projection","resolution","clearColor","parseInt","substring","colorMask","enable","DEPTH_TEST","clearDepth","depthFunc","LEQUAL","BLEND","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","blendEquationSeparate","FUNC_ADD","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","SCISSOR_TEST","scissor","viewport","set","createShaderProgram","createVertexBuffer","createElementBuffer","createUniformBuffer","loadImage","url","Promise","resolve","reject","img","Image","onload","onerror","src","loadTextureFromUrl","WebGLCanvas","ShaderProgram","Buffer","VertexBuffer","ElementBuffer","UniformBuffer","VertexArray","Texture"],"version":3,"file":"froxel-gl.m.js.map"}