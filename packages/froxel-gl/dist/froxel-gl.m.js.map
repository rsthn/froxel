{"mappings":"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","sources":["<anon>","src/main.js","src/webgl-canvas.js","src/shader-program.js","src/uniform-block-buffer.js","src/buffer.js","src/vertex-buffer.js","src/element-buffer.js","src/vertex-array.js","src/texture.js"],"sourcesContent":["import {Vec4 as $k7heJ$Vec4, Mat4 as $k7heJ$Mat4} from \"froxel-math\";\n\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\n\n\n\nclass $8130a8013106f3d1$export$2e2bcd8739ae039 {\n    /**\n\t * Reference to the WebGLCanvas.\n\t * @readonly @type {WebGLCanvas}\n\t */ gl;\n    /**\n\t * Buffer target.\n\t * @type {number}\n\t */ target;\n    /**\n\t * Buffer usage mode.\n\t * @type {number}\n\t */ usage;\n    /**\n\t * Buffer object resource.\n\t * @type {WebGLBuffer}\n\t */ buffer;\n    /**\n\t * Creates a WebGL buffer.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} target\n\t * @param {number} usage\n\t */ constructor(gl, target, usage){\n        this.gl = gl;\n        this.target = target;\n        this.usage = usage;\n        this.buffer = gl.genBuffer();\n    }\n    /**\n\t * Binds the buffer to its WebGL target.\n\t * @returns {Buffer}\n\t */ bindBuffer() {\n        this.gl.bindBuffer(this.target, this.buffer);\n        return this;\n    }\n    /**\n\t * Unbinds the buffer from its GPU buffer target.\n\t * @returns {Buffer}\n\t */ unbindBuffer() {\n        this.gl.bindBuffer(this.target, null);\n        return this;\n    }\n    /**\n\t * Initializes and creates the buffer object's data store.\n\t * @param {ArrayBufferView} srcData\n\t * @param {number} srcOffset?\n\t * @returns {Buffer}\n\t */ bufferData(srcData, srcOffset = 0) {\n        this.bindBuffer();\n        this.gl.bufferData(this.target, srcData, this.usage, srcOffset);\n        return this;\n    }\n    /**\n\t * Allocates the specified number of bytes for the buffer.\n\t * @param {number} numBytes\n\t * @returns {Buffer}\n\t */ allocate(numBytes) {\n        this.bindBuffer();\n        this.gl.bufferData(this.target, numBytes, this.usage);\n        return this;\n    }\n    /**\n\t * Updates a subset of the buffer object's data store. \n\t * @param {number} dstByteOffset\n\t * @param {ArrayBufferView} srcData\n\t * @param {number} srcOffset?\n\t * @param {number} length?\n\t * @returns {Buffer}\n\t */ bufferSubData(dstByteOffset, srcData, srcOffset = 0, length = 0) {\n        this.bindBuffer();\n        this.gl.bufferSubData(this.target, dstByteOffset, srcData, srcOffset, length ? length : srcData.length);\n        return this;\n    }\n    /**\n\t * Deletes the buffer.\n\t */ deleteBuffer() {\n        this.gl.deleteBuffer(this.buffer);\n    }\n}\n\n\nclass $e784d1790a77f0a9$export$2e2bcd8739ae039 extends (0, $8130a8013106f3d1$export$2e2bcd8739ae039) {\n    /**\n\t * Uniform block binding index. Set using `bindBufferBase`.\n\t * @readonly @type {number}\n\t */ bindingIndex;\n    /**\n\t * Creates a buffer for the UNIFORM_BUFFER target.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} usage\n\t */ constructor(gl, usage){\n        super(gl, gl.UNIFORM_BUFFER, usage);\n    }\n    /**\n\t * Binds the buffer to the UNIFORM_BUFFER binding point at a given index. \n\t * @param {number} index\n\t * @returns {UniformBlockBuffer}\n\t */ bindBufferBase(index) {\n        this.gl.bindBufferBase(this.target, this.bindingIndex = index, this.buffer);\n        return this;\n    }\n}\n\n\nvar $f833e504115047ce$export$2e2bcd8739ae039 = $f833e504115047ce$var$ShaderProgram;\n/**\n * Creates a WebGL GLSL Shader Program.\n * @param {WebGLCanvas} gl\n * @param {string} vertexShaderSource\n * @param {string} fragmentShaderSource\n */ function $f833e504115047ce$var$ShaderProgram(gl, vertexShaderSource, fragmentShaderSource) {\n    /**\n\t * Reference to the WebGLCanvas.\n\t * @readonly @type {WebGLCanvas}\n\t */ this.gl = gl;\n    /**\n\t * Vertex shader resource object.\n\t * @readonly @type {WebGLShader}\n\t */ this.vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(this.vertexShader, vertexShaderSource);\n    gl.compileShader(this.vertexShader);\n    /**\n\t * Fragment shader resource object.\n\t * @readonly @type {WebGLShader}\n\t */ this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(this.fragmentShader, fragmentShaderSource);\n    gl.compileShader(this.fragmentShader);\n    /**\n\t * Shader program resource object.\n\t * @readonly @type {WebGLProgram}\n\t */ this.program = gl.createProgram();\n    gl.attachShader(this.program, this.vertexShader);\n    gl.attachShader(this.program, this.fragmentShader);\n}\n/**\n * Links the program and throws an error if there was any problem.\n * @throws {Error}\n * @returns {ShaderProgram}\n */ $f833e504115047ce$var$ShaderProgram.prototype.linkProgram = function() {\n    for(let attribName in $f833e504115047ce$var$ShaderProgram.attribLocations)this.gl.bindAttribLocation(this.program, $f833e504115047ce$var$ShaderProgram.attribLocations[attribName], attribName);\n    this.gl.linkProgram(this.program);\n    if (this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {\n        this.gl.deleteShader(this.vertexShader);\n        this.gl.deleteShader(this.fragmentShader);\n        return this;\n    }\n    let vertexError = this.gl.getShaderInfoLog(this.vertexShader);\n    let fragmentError = this.gl.getShaderInfoLog(this.fragmentShader);\n    throw new Error(vertexError ? \"• Vertex Shader:\\n\" + vertexError + \"\\n\" : \"\" + fragmentError ? \"• Fragment Shader:\\n\" + fragmentError : \"\");\n};\n/**\n * Binds an attribute location to the shader program.\n * @param {number} attribLocation\n * @param {string} attribName\n * @returns {ShaderProgram}\n */ $f833e504115047ce$var$ShaderProgram.prototype.bindAttribLocation = function(attribLocation, attribName) {\n    this.gl.bindAttribLocation(this.program, attribLocation, attribName);\n    return this;\n};\n/**\n * Map of global attribute locations.\n * @readonly @private\n * @type {Map<string, number>}\n */ $f833e504115047ce$var$ShaderProgram.attribLocations = new Map();\n/**\n * Binds a global attribute location to be applied to any newly created shader program.\n * @param {number} attribLocation\n * @param {string} attribName\n * @returns {ShaderProgram}\n */ $f833e504115047ce$var$ShaderProgram.bindAttribLocation = function(attribLocation, attribName) {\n    this.attribLocations[attribName] = attribLocation;\n    return this;\n};\n/**\n * Binds several global attribute locations to be applied to any newly created shader program.\n * @param {Map<string, number>} attribs\n * @returns {ShaderProgram}\n */ $f833e504115047ce$var$ShaderProgram.bindAttribLocations = function(attribs) {\n    for(let attribName in attribs)this.attribLocations[attribName] = attribs[attribName];\n    return this;\n};\n/**\n * Activates the shader program for subsequent drawing operations.\n */ $f833e504115047ce$var$ShaderProgram.prototype.useProgram = function() {\n    this.gl.useProgram(this.program);\n};\n/**\n * Returns the location of a uniform variable.\n * @param {string} uniformName\n * @returns {WebGLUniformLocation}\n */ $f833e504115047ce$var$ShaderProgram.prototype.getUniformLocation = function(uniformName) {\n    // TODO Add cache here.\n    return this.gl.getUniformLocation(this.program, uniformName);\n};\n/**\n * Returns the location of one or more uniform variables.\n * @param {Array<string>} uniformNames\n * @returns { [key: string]: WebGLUniformLocation }\n */ $f833e504115047ce$var$ShaderProgram.prototype.getUniformLocations = function(uniformNames) {\n    let uniforms = {};\n    for (let uniformName of uniformNames)uniforms[uniformName] = this.getUniformLocation(uniformName);\n    return uniforms;\n};\n/**\n * Returns the index and offset of one or more uniform variables. Useful when using uniform block objects (UBO).\n * @param {Array<string>} uniformNames\n * @returns { [key: string]: { index: number, offset: number } }\n */ $f833e504115047ce$var$ShaderProgram.prototype.getUniformOffsets = function(uniformNames) {\n    let uniforms = {};\n    let indices = this.gl.getUniformIndices(this.program, uniformNames);\n    let offsets = this.gl.getActiveUniforms(this.program, indices, this.gl.UNIFORM_OFFSET);\n    for(let i in uniformNames)uniforms[uniformNames[i]] = {\n        index: indices[i],\n        offset: offsets[i]\n    };\n    return uniforms;\n};\n/**\n * Returns the index of a uniform block.\n * @param {string} blockName\n * @returns {number}\n */ $f833e504115047ce$var$ShaderProgram.prototype.getUniformBlockIndex = function(blockName) {\n    // TODO Add cache here?\n    return this.gl.getUniformBlockIndex(this.program, blockName);\n};\n/**\n * Returns the indices of one or more uniform blocks.\n * @param {Array<string>} blockNames\n * @returns { [key: string]: number }\n */ $f833e504115047ce$var$ShaderProgram.prototype.getUniformBlockIndices = function(blockNames) {\n    let indices = {};\n    for (let blockName of blockNames)indices[blockName] = this.getUniformBlockIndex(blockName);\n    return indices;\n};\n/**\n * Assigns the binding index of a uniform block buffer to a block identifier in the program.\n * @param {number|string} blockIdentifier\n * @param {number|UniformBlockBuffer} bindingIndex\n * @returns {ShaderProgram}\n */ $f833e504115047ce$var$ShaderProgram.prototype.uniformBlockBinding = function(blockIdentifier, bindingIndex) {\n    if (typeof blockIdentifier === \"string\") blockIdentifier = this.getUniformBlockIndex(blockIdentifier);\n    if (bindingIndex instanceof (0, $e784d1790a77f0a9$export$2e2bcd8739ae039)) bindingIndex = bindingIndex.bindingIndex;\n    return this.gl.uniformBlockBinding(this.program, blockIdentifier, bindingIndex);\n};\n\n\n\n\nclass $bae776f183aa91d1$export$2e2bcd8739ae039 extends (0, $8130a8013106f3d1$export$2e2bcd8739ae039) {\n    /**\n\t * Creates a buffer for the ARRAY_BUFFER target.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} usage\n\t */ constructor(gl, usage){\n        super(gl, gl.ARRAY_BUFFER, usage);\n    }\n}\n\n\n\n\nclass $6d7095e563bd49c3$export$2e2bcd8739ae039 extends (0, $8130a8013106f3d1$export$2e2bcd8739ae039) {\n    /**\n\t * Creates a buffer for the ELEMENT_ARRAY_BUFFER target.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} usage\n\t */ constructor(gl, usage){\n        super(gl, gl.ELEMENT_ARRAY_BUFFER, usage);\n    }\n}\n\n\n\nvar $4edd0ce7f9f6daf0$export$2e2bcd8739ae039 = $4edd0ce7f9f6daf0$var$VertexArray;\n/**\n * Creates a Vertex Array Object (VAO).\n * @param {WebGLCanvas} gl\n */ function $4edd0ce7f9f6daf0$var$VertexArray(gl) {\n    /**\n\t * Reference to the WebGLCanvas.\n\t * @readonly @type {WebGLCanvas}\n\t */ this.gl = gl;\n    /**\n\t * Vertex array object resource.\n\t * @type {WebGLVertexArrayObject}\n\t */ this.vertexArray = gl.genVertexArray();\n}\n/**\n * Binds the vertex array object to the GPU.\n */ $4edd0ce7f9f6daf0$var$VertexArray.prototype.bindVertexArray = function() {\n    this.gl.bindVertexArray(this.vertexArray);\n};\n/**\n * Unbinds the vertex array object from the GPU.\n */ $4edd0ce7f9f6daf0$var$VertexArray.prototype.unbindVertexArray = function() {\n    this.gl.bindVertexArray(null);\n};\n\n\n\n\nclass $1f22c8a97caed0f2$export$2e2bcd8739ae039 {\n    /**\n\t * Reference to the WebGLCanvas.\n\t * @readonly @type {WebGLCanvas}\n\t */ gl;\n    /**\n\t * Texture object resource.\n\t * @readonly @type {WebGLTexture}\n\t */ texture;\n    /**\n\t * Texture width (physical width).\n\t * @readonly @type {number}\n\t */ width;\n    /**\n\t * Texture height (physical height).\n\t * @readonly @type {number}\n\t */ height;\n    /**\n\t * Target width originally requested (logical width).\n\t * @readonly @type {number}\n\t */ targetWidth;\n    /**\n\t * Target height originally requested (logical height).\n\t * @readonly @type {number}\n\t */ targetHeight;\n    /**\n\t * Scale of the texture (physical width / logical width).\n\t * @readonly @type {number}\n\t */ scale;\n    /**\n\t * Texture filter type. Defaults to `LINEAR`.\n\t * @readonly @type {TextureFilterType}\n\t */ filterType;\n    /**\n\t * Texture wrap mode. Defaults to `CLAMP_TO_EDGE`.\n\t * @readonly @type {TextureWrapMode}\n\t */ wrapMode;\n    /**\n\t * Number of mipmap levels (use 0 to disable). Default is `0`.\n\t * @readonly @type {number}\n\t */ mipmapLevels;\n    /**\n\t * Indicates if the texture storage has already been allocated.\n\t * @readonly @private @type {boolean}\n\t */ allocated;\n    /**\n\t * Creates an empty texture object of the specified size.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} width - Physical texture width.\n\t * @param {number} height - Physical texture height.\n\t * @param {number} [targetWidth] - Logical texture width.\n\t * @param {number} [targetHeight] - Logical texture height.\n\t */ constructor(gl, width, height, targetWidth = null, targetHeight = null){\n        this.gl = gl;\n        this.texture = gl.genTexture();\n        this.width = width;\n        this.height = height;\n        this.targetWidth = targetWidth ?? width;\n        this.targetHeight = targetHeight ?? height;\n        this.scale = this.width / this.targetWidth;\n        this.allocated = false;\n        this.mipmapLevels = 0;\n        this.wrapMode = \"CLAMP_TO_EDGE\";\n        this.filterType = \"LINEAR\";\n    }\n    /**\n\t * Binds the texture to the `TEXTURE_2D` target and allocates the texture storage if not allocated yet.\n\t * @returns {Texture}\n\t */ bindTexture() {\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n        if (this.allocated !== false) return this;\n        this.allocated = null;\n        this.allocate();\n        return this;\n    }\n    /**\n\t * Allocates the texture storage.\n\t * @returns {Texture}\n\t */ allocate() {\n        if (this.allocated === true) return this;\n        this.allocated = true;\n        this.bindTexture().applyFilter().applyWrap();\n        if (this.mipmapLevels > 0) this.gl.texStorage2D(this.gl.TEXTURE_2D, this.mipmapLevels, this.gl.RGBA8, this.width, this.height);\n        else this.gl.texStorage2D(this.gl.TEXTURE_2D, 1, this.gl.RGBA8, this.width, this.height);\n        return this;\n    }\n    /**\n\t * Applies the texture filter.\n\t * @private\n\t * @param {boolean} [bindTexture]\n\t * @returns {Texture}\n\t */ applyFilter(bindTexture = false) {\n        if (bindTexture) this.bindTexture();\n        let minFilter = this.gl.LINEAR;\n        let magFilter = this.gl.LINEAR;\n        if (this.filterType === \"NEAREST\") minFilter = magFilter = this.gl.NEAREST;\n        if (this.mipmapLevels > 0) {\n            minFilter = this.gl.LINEAR_MIPMAP_LINEAR;\n            if (this.filterType === \"NEAREST\") minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n        }\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, minFilter);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, magFilter);\n        return this;\n    }\n    /**\n\t * Applies the texture wrap mode.\n\t * @private\n\t * @param {boolean} [bindTexture]\n\t * @returns {Texture}\n\t */ applyWrap(bindTexture = false) {\n        if (bindTexture) this.bindTexture();\n        let wrapMode = this.gl.CLAMP_TO_EDGE;\n        if (this.wrapMode === \"REPEAT\") wrapMode = this.gl.REPEAT;\n        else if (this.wrap === \"MIRRORED_REPEAT\") wrapMode = this.gl.MIRRORED_REPEAT;\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, wrapMode);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, wrapMode);\n        return this;\n    }\n    /**\n\t * Sets the texture filter type.\n\t * @param {TextureFilterType} filterType\n\t * @returns {Texture}\n\t */ setFilter(filterType) {\n        this.filterType = filterType;\n        return this.allocated === true ? this.applyFilter(true) : this;\n    }\n    /**\n\t * Sets the texture wrap mode.\n\t * @param {TextureWrapMode} wrapMode\n\t * @returns {Texture}\n\t */ setWrapMode(wrapMode) {\n        this.wrapMode = wrapMode;\n        return this.allocated === true ? this.applyWrap(true) : this;\n    }\n    /**\n\t * Sets the number of mipmap levels. Valid only if texture data has not been allocated yet.\n\t * @param {number} numLevels\n\t * @returns {Texture}\n\t */ setMipmapLevels(numLevels) {\n        if (this.allocated === true) return this;\n        this.mipmapLevels = Math.max(0, numLevels);\n        return this;\n    }\n    /**\n\t * Uploads data to the GPU from the specified image.\n\t * @param {HTMLImageElement} image\n\t * @param {number} [offsX] - Target X offset.\n\t * @param {number} [offsY] - Target Y offset;\n\t * @returns {Texture}\n\t */ upload(image, offsX = 0, offsY = 0) {\n        this.bindTexture();\n        this.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, offsX, offsY, Math.min(image.width, this.width), Math.min(image.height, this.height), this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\n        if (this.mipmapLevels > 0) this.gl.generateMipmap(this.gl.TEXTURE_2D);\n        return this;\n    }\n    /**\n\t * Makes the texture active on the specified texture unit.\n\t * @param {number} unit - Texture unit index (0 to 15).\n\t * @returns {Texture}\n\t */ activeTexture(unit) {\n        this.gl.activeTexture(this.gl.TEXTURE0 + (unit & 15));\n        this.bindTexture();\n        return this;\n    }\n}\n\n\n\n\nvar $87df07883f23e949$export$2e2bcd8739ae039 = $87df07883f23e949$var$WebGLCanvas;\n/**\n * @typedef {'default'|'landscape'|'portrait'|'automatic'|'strict'} WebGLCanvasOrientation\n */ /**\n * @typedef {Object} WebGLCanvasOptions\n * @prop {boolean} [fullscreen] Positions the canvas to cover the entire screen. default `true`\n * @prop {boolean} [stencil] Indicates if the stencil buffer should be enabled. default `false`\n * @prop {string} [background] Background color, must be a 6-digit hex RGB value. default `000000`\n * @prop {number} [width] Width of the canvas, used only when `fullscreen` is `false`. default `960`\n * @prop {number} [height] Height of the canvas, used only when `fullscreen` is `false`. default `540`\n * @prop {WebGLCanvasOrientation} [orientation] Orientation of the canvas. Defaults to `AUTOMATIC`.\n * @prop {boolean} [antialias] Controls the antialias option, set to `false` for pixel-perfect output. Default is `true`.\n * @prop {number} [scaleFactorMax] Limit of the scale factor, used only when set to greater than zero.\n * @prop {number} [scaleFactorOffs] Offset used to increase the scale factor before the Math.floor operation. Default is `0.7`.\n */ const $87df07883f23e949$var$defaultOptions = {\n    fullscreen: true,\n    stencil: false,\n    background: \"000000\",\n    width: 960,\n    height: 540,\n    orientation: \"automatic\",\n    antialias: true,\n    scaleFactorMax: 0,\n    scaleFactorOffs: 0.7\n};\n/**\n * List of active canvases. Registered when the WebGLCanvas is created, and removed when it is disposed.\n */ const $87df07883f23e949$var$activeCanvases = [];\n/**\n * Indicates if the auto-resizer has been attached to the window.\n */ let $87df07883f23e949$var$autoResizerAttached = false;\n/**\n * \n */ function $87df07883f23e949$var$autoResizeCanvas(wgl) {\n    let fullWidth = wgl.options.width;\n    let fullHeight = wgl.options.height;\n    if (wgl.options.fullscreen && \"document\" in $parcel$global) {\n        fullWidth = Math.floor($parcel$global.innerWidth);\n        fullHeight = Math.floor($parcel$global.innerHeight);\n    } else {\n        if (wgl.options.width === null && wgl.options.height === null) throw new Error(\"At least one screen dimension must be specified in headless mode.\");\n    }\n    // Flip dimensions to ensure the desired orientation.\n    let currentWidth = fullWidth;\n    let currentHeight = fullHeight;\n    let flipped = false;\n    if (fullWidth < fullHeight && wgl.options.orientation === \"landscape\" || fullWidth > fullHeight && wgl.options.orientation === \"portrait\") {\n        currentWidth = fullHeight;\n        currentHeight = fullWidth;\n        flipped = true;\n    }\n    // Get target screen dimensions.\n    let targetWidth = wgl.options.width;\n    let targetHeight = wgl.options.height;\n    if (targetWidth === null || targetHeight === null) {\n        if (targetWidth === null && targetHeight === null) {\n            targetWidth = currentWidth;\n            targetHeight = currentHeight;\n        } else if (targetWidth === null) targetWidth = Math.floor(0.5 + currentWidth * (wgl.options.height / currentHeight));\n        else targetHeight = Math.floor(0.5 + currentHeight * (wgl.options.width / currentWidth));\n    }\n    // Handle `automatic` canvas orientation.\n    let screenWidth = targetWidth;\n    let screenHeight = targetHeight;\n    if (wgl.options.orientation === \"automatic\" && screenWidth && screenHeight) {\n        if (screenWidth > screenHeight && currentWidth < currentHeight || screenWidth < screenHeight && currentWidth > currentHeight) {\n            screenWidth = targetHeight;\n            screenHeight = targetWidth;\n        }\n    }\n    // Compute canvas scale factor.\n    let canvasScaleFactor = 1;\n    if (screenWidth && screenHeight) canvasScaleFactor = Math.min(currentWidth / screenWidth, currentHeight / screenHeight);\n    else if (screenWidth) canvasScaleFactor = currentWidth / screenWidth;\n    else if (screenHeight) canvasScaleFactor = currentHeight / screenHeight;\n    // ***\n    let tmpWidth = currentWidth;\n    let tmpHeight = currentHeight;\n    if (screenWidth) currentWidth = screenWidth;\n    if (screenHeight) currentHeight = screenHeight;\n    let offsX = Math.floor((tmpWidth - currentWidth * canvasScaleFactor) * 0.5);\n    let offsY = Math.floor((tmpHeight - currentHeight * canvasScaleFactor) * 0.5);\n    if (flipped) {\n        let tmp = offsX;\n        offsX = offsY;\n        offsY = tmp;\n    }\n    let scaleFactor = canvasScaleFactor * $parcel$global.devicePixelRatio;\n    scaleFactor = Math.floor(wgl.options.scaleFactorOffs + scaleFactor);\n    if (wgl.options.scaleFactorMax > 0 && scaleFactor > wgl.options.scaleFactorMax) scaleFactor = wgl.options.scaleFactorMax;\n    if (wgl.options.fullscreen && \"document\" in $parcel$global) $parcel$global.document.body.style.backgroundColor = wgl.element.style.backgroundColor;\n    wgl.resize(currentWidth, currentHeight, false);\n    if (!flipped) {\n        wgl.element.style.width = Math.floor(currentWidth * canvasScaleFactor + 0.5) + \"px\";\n        wgl.element.style.height = Math.floor(currentHeight * canvasScaleFactor + 0.5) + \"px\";\n    } else {\n        wgl.element.style.width = Math.floor(currentHeight * canvasScaleFactor + 0.5) + \"px\";\n        wgl.element.style.height = Math.floor(currentWidth * canvasScaleFactor + 0.5) + \"px\";\n    }\n    wgl.element.style.marginLeft = offsX + \"px\";\n    wgl.element.style.marginTop = offsY + \"px\";\n    wgl.globalScale = scaleFactor;\n    wgl.isFlipped = flipped;\n    wgl.u.initial.identity();\n    wgl.u.initial.scale(scaleFactor, scaleFactor, scaleFactor);\n    if (flipped) {\n        wgl.u.initial.rotateZ(Math.PI / 2);\n        wgl.u.initial.translate(-currentWidth, 0, 0);\n    }\n    wgl.updateViewport();\n//console.log('logical', wgl.width, wgl.height);\t\n//console.log('canvas-logical', wgl.element.width, wgl.element.height);\n//console.log('canvas-css', wgl.element.style.width, wgl.element.style.height);\n//console.log('phys', wgl.physWidth, wgl.physHeight);\n//console.log('webGl', wgl.gl.drawingBufferWidth, wgl.gl.drawingBufferHeight);\n//console.log('globalScale', wgl.globalScale);\n//console.log('canvasScaleFactor', canvasScaleFactor);\n/* *** */ //if (options.maxScaleFactor > 0 && scaleFactor > options.maxScaleFactor)\n//\tscaleFactor = options.maxScaleFactor;\n//_this.integerScaleFactor = Math.floor(scaleFactor + 0.5); //0.9\n}\n/**\n * WebGL2 Canvas.\n *\n * Default WebGL configuration is set as follows:\n *\n * - `DEPTH_TEST`: enabled, `clearDepth`: -1.0, `depthFunc`: GEQUAL\n * - `BLEND`: enabled, `blendEquationSeparate`: FUNC_ADD, FUNC_ADD, `blendFunc`: ONE, ONE_MINUS_SRC_ALPHA\n * - `UNPACK_PREMULTIPLY_ALPHA_WEBGL`: enabled\n * - `SCISSOR_TEST`: enabled\n *\n * @extends {WebGL2RenderingContext}\n * @param {WebGLCanvasOptions} [options]\n */ function $87df07883f23e949$var$WebGLCanvas(options = null) {\n    if (!$87df07883f23e949$var$autoResizerAttached) {\n        $parcel$global.onresize = function() {\n            for (let wgl of $87df07883f23e949$var$activeCanvases)$87df07883f23e949$var$autoResizeCanvas(wgl);\n        };\n        $87df07883f23e949$var$autoResizerAttached = true;\n    }\n    this.init({\n        ...$87df07883f23e949$var$defaultOptions,\n        ...options\n    });\n    $87df07883f23e949$var$activeCanvases.push(this);\n}\n/**\n * Disposes the canvas and all related resources.\n */ $87df07883f23e949$var$WebGLCanvas.prototype.dispose = function() {\n    $87df07883f23e949$var$activeCanvases.splice($87df07883f23e949$var$activeCanvases.indexOf(this), 1);\n};\n/**\n * WebGL2 Context.\n * @private @readonly @type {WebGL2RenderingContext}\n */ $87df07883f23e949$var$WebGLCanvas.prototype.gl = null;\n/**\n * @typedef {Object} WebGLCanvasUniforms\n * @prop {boolean} changed Indicates if the uniforms have changed and should be reloaded in the WebGL program.\n * @prop {Vec4} resolution Canvas resolution (automatically set by WebGLCanvas).\n * @prop {Mat4} initial Transformation to achieve correct target resolution and orientation (automatically set by WebGLCanvas).\n * @prop {Mat4} view Transforms coordinates to view space.\n * @prop {Mat4} projection Transforms coordinates to NDC space. Use the `setOrtho2D`, `setOrtho3D` or `setFrustrum` methods of Utils to configure its value.\n * @prop {Mat4} mvp Model-view-projection (MVP) matrix contains all transformations in a single matrix.\n */ /**\n * Common uniforms for WebGL. Note that it is the responsibility of the developer to set, configure and use these uniforms (except the ones marked\n * as \"automatically set by WebGLCanvas\"). Thse are provided solely as placeholders for easy access from a known interface.\n * @readonly @type {WebGLCanvasUniforms}\n */ $87df07883f23e949$var$WebGLCanvas.prototype.u = null;\n/**\n * Underlying HTML5 canvas element.\n * @readonly @type {HTMLCanvasElement}\n */ $87df07883f23e949$var$WebGLCanvas.prototype.element = null;\n/**\n * Logical width of the canvas.\n * @readonly @type {number}\n */ $87df07883f23e949$var$WebGLCanvas.prototype.width = 0;\n/**\n * Logical height of the canvas.\n * @readonly @type {number}\n */ $87df07883f23e949$var$WebGLCanvas.prototype.height = 0;\n/**\n * Physical canvas width.\n * @readonly @type {number}\n */ $87df07883f23e949$var$WebGLCanvas.prototype.physWidth = 0;\n/**\n * Physical canvas height.\n * @readonly @type {number}\n */ $87df07883f23e949$var$WebGLCanvas.prototype.physHeight = 0;\n/**\n * Indicates if the canvas is flipped.\n * @readonly @type {boolean}\n */ $87df07883f23e949$var$WebGLCanvas.prototype.isFlipped = false;\n/**\n * Canvas global scale.\n * @readonly @type {number}\n */ $87df07883f23e949$var$WebGLCanvas.prototype.globalScale = 1.0;\n/**\n * Functions that are under a different name in WebGLCanvas from the original WebGL2RenderingContext.\n */ const $87df07883f23e949$var$renamedFunctions = {\n    createTexture: \"genTexture\",\n    createBuffer: \"genBuffer\",\n    createVertexArray: \"genVertexArray\"\n};\n/**\n * Initializes the instance.\n * @private\n */ $87df07883f23e949$var$WebGLCanvas.prototype.init = function(options) {\n    this.element = document.createElement(\"canvas\");\n    this.options = options;\n    if (!options.fullscreen && (!options.width || !options.height)) throw new Error(\"Option `width` or `height` is missing while `fullscreen` is `false`.\");\n    if (options.background.length != 6) throw new Error(\"Option `background` should be a 6-digit hex RGB (i.e. 000000).\");\n    this.element.style.imageRendering = options.antialias ? \"auto\" : \"crisp-edges\";\n    this.element.style.backgroundColor = \"#\" + options.background;\n    if (options.fullscreen) {\n        this.element.style.position = \"absolute\";\n        this.element.style.left = \"0px\";\n        this.element.style.top = \"0px\";\n    }\n    // Get WebGL context and re-bind functions and values to the WebGLCanvas object.\n    this.gl = this.element.getContext(\"webgl2\", {\n        desynchronized: false,\n        preserveDrawingBuffer: false,\n        alpha: false,\n        stencil: options.stencil\n    });\n    for(let prop in this.gl){\n        let val = this.gl[prop];\n        switch(typeof val){\n            case \"function\":\n                if (prop in $87df07883f23e949$var$renamedFunctions) prop = $87df07883f23e949$var$renamedFunctions[prop];\n                this[prop] = val.bind(this.gl);\n                break;\n            case \"number\":\n                this[prop] = val;\n                break;\n        }\n    }\n    console.log(this.getParameter(this.VERSION) + \", \" + this.getParameter(this.SHADING_LANGUAGE_VERSION));\n    // Allocate placeholder for uniforms.\n    this.u = {\n        changed: true,\n        resolution: (0, $k7heJ$Vec4).alloc(),\n        initial: (0, $k7heJ$Mat4).alloc(),\n        view: (0, $k7heJ$Mat4).alloc(),\n        projection: (0, $k7heJ$Mat4).alloc(),\n        mvp: (0, $k7heJ$Mat4).alloc()\n    };\n    // Initialize default configuration.\n    this.clearColor(parseInt(options.background.substring(0, 2), 16) / 255.0, parseInt(options.background.substring(2, 4), 16) / 255.0, parseInt(options.background.substring(4, 6), 16) / 255.0, 1.0);\n    this.colorMask(true, true, true, true);\n    this.enable(this.DEPTH_TEST);\n    this.clearDepth(-1);\n    this.depthFunc(this.GEQUAL);\n    this.enable(this.BLEND);\n    this.pixelStorei(this.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n    this.blendEquationSeparate(this.FUNC_ADD, this.FUNC_ADD);\n    this.blendFunc(this.ONE, this.ONE_MINUS_SRC_ALPHA);\n    this.enable(this.SCISSOR_TEST);\n    $87df07883f23e949$var$autoResizeCanvas(this);\n};\n/**\n * Resizes the canvas to the specified logical size.\n * @param {number} width\n * @param {number} height\n */ $87df07883f23e949$var$WebGLCanvas.prototype.resize = function(width, height, updateViewport = true) {\n    this.width = width;\n    this.height = height;\n    if (updateViewport) this.updateViewport();\n};\n$87df07883f23e949$var$WebGLCanvas.prototype.updateViewport = function() {\n    this.physWidth = this.element.width = Math.floor((this.isFlipped ? this.height : this.width) * this.globalScale);\n    this.physHeight = this.element.height = Math.floor((this.isFlipped ? this.width : this.height) * this.globalScale);\n    this.scissor(0, 0, this.physWidth, this.physHeight);\n    this.viewport(0, 0, this.physWidth, this.physHeight);\n    //violet:hardware scaling? currently we're using canvas browser-level scaling.\n    //this.v_resolution[0] = this._width;\n    //this.v_resolution[1] = this._height;\n    this.u.resolution.set(this.physWidth, this.physHeight, this.isFlipped ? this.physHeight : this.physWidth, this.isFlipped ? this.physWidth : this.physHeight);\n    this.u.changed = true;\n};\n/**\n * Creates a shader program with the specified vertex and fragment shader source codes.\n * @param {string} vertexShaderSource\n * @param {string} fragmentShaderSource\n * @returns {ShaderProgram}\n */ $87df07883f23e949$var$WebGLCanvas.prototype.createShaderProgram = function(vertexShaderSource, fragmentShaderSource) {\n    return new (0, $f833e504115047ce$export$2e2bcd8739ae039)(this, vertexShaderSource, fragmentShaderSource);\n};\n/**\n * Creates a new vertex array object.\n * @returns {VertexArray}\n */ $87df07883f23e949$var$WebGLCanvas.prototype.createVertexArray = function() {\n    return new (0, $4edd0ce7f9f6daf0$export$2e2bcd8739ae039)(this);\n};\n/**\n * Creates a new buffer.\n * @param {number} target Possible values are: `ARRAY_BUFFER`, `ELEMENT_ARRAY_BUFFER`, `COPY_READ_BUFFER`, `COPY_WRITE_BUFFER`, `TRANSFORM_FEEDBACK_BUFFER`, `UNIFORM_BUFFER`, `PIXEL_PACK_BUFFER`, or `PIXEL_UNPACK_BUFFER`.\n * @param {number} usage Possible values are: `STATIC_DRAW`, `DYNAMIC_DRAW`, `STREAM_DRAW`, `STATIC_READ`, `DYNAMIC_READ`, `STREAM_READ`, `STATIC_COPY`, `DYNAMIC_COPY`, or `STREAM_COPY`.\n * @returns {VertexBuffer}\n */ $87df07883f23e949$var$WebGLCanvas.prototype.createBuffer = function(target, usage) {\n    return new (0, $8130a8013106f3d1$export$2e2bcd8739ae039)(this, target, usage);\n};\n/**\n * Creates a new vertex buffer.\n * @param {number} usage Possible values are: `STATIC_DRAW`, `DYNAMIC_DRAW`, `STREAM_DRAW`, `STATIC_READ`, `DYNAMIC_READ`, `STREAM_READ`, `STATIC_COPY`, `DYNAMIC_COPY`, or `STREAM_COPY`.\n * @returns {VertexBuffer}\n */ $87df07883f23e949$var$WebGLCanvas.prototype.createVertexBuffer = function(usage) {\n    return new (0, $bae776f183aa91d1$export$2e2bcd8739ae039)(this, usage);\n};\n/**\n * Creates a new element buffer.\n * @param {number} usage Possible values are: `STATIC_DRAW`, `DYNAMIC_DRAW`, `STREAM_DRAW`, `STATIC_READ`, `DYNAMIC_READ`, `STREAM_READ`, `STATIC_COPY`, `DYNAMIC_COPY`, or `STREAM_COPY`.\n * @returns {ElementBuffer}\n */ $87df07883f23e949$var$WebGLCanvas.prototype.createElementBuffer = function(usage) {\n    return new (0, $6d7095e563bd49c3$export$2e2bcd8739ae039)(this, usage);\n};\n/**\n * Creates a new uniform block buffer.\n * @param {number} usage Possible values are: `STATIC_DRAW`, `DYNAMIC_DRAW`, `STREAM_DRAW`, `STATIC_READ`, `DYNAMIC_READ`, `STREAM_READ`, `STATIC_COPY`, `DYNAMIC_COPY`, or `STREAM_COPY`.\n * @returns {UniformBlockBuffer}\n */ $87df07883f23e949$var$WebGLCanvas.prototype.createUniformBlockBuffer = function(usage) {\n    return new (0, $e784d1790a77f0a9$export$2e2bcd8739ae039)(this, usage);\n};\n/**\n * Creates a new texture object of the specified size.\n * @param {number} width - Physical texture width.\n * @param {number} height - Physical texture height.\n * @param {number} [targetWidth] - Logical texture width.\n * @param {number} [targetHeight] - Logical texture height.\n * @returns {Texture}\n */ $87df07883f23e949$var$WebGLCanvas.prototype.createTexture = function(width, height, targetWidth = null, targetHeight = null) {\n    return new (0, $1f22c8a97caed0f2$export$2e2bcd8739ae039)(this, width, height, targetWidth, targetHeight);\n};\n/**\n * Loads an image from the specified URL.\n * @param {string} url\n * @returns {Promise<HTMLImageElement>}\n */ $87df07883f23e949$var$WebGLCanvas.loadImage = function(url) {\n    return new Promise((resolve, reject)=>{\n        let img = new Image();\n        img.onload = ()=>resolve(img);\n        img.onerror = ()=>reject(\"Unable to load image: \" + url);\n        img.src = url;\n    });\n};\n/**\n * Loads an image from the specified URL and creates a texture.\n * @param {string} url\n * @param {number} [mipmapLevels] - Number of levels for mipmapping. Defaults to `0`.\n * @returns {Promise<Texture>}\n */ $87df07883f23e949$var$WebGLCanvas.prototype.loadTextureFromUrl = async function(url, mipmapLevels = 0) {\n    let image = await $87df07883f23e949$var$WebGLCanvas.loadImage(url);\n    let texture = this.createTexture(image.width, image.height);\n    console.log(texture);\n    texture.setMipmapLevels(mipmapLevels);\n    texture.upload(image);\n    return texture;\n};\n\n\n\n\n\n\n\n\n\n\n\nexport {$87df07883f23e949$export$2e2bcd8739ae039 as WebGLCanvas, $f833e504115047ce$export$2e2bcd8739ae039 as ShaderProgram, $8130a8013106f3d1$export$2e2bcd8739ae039 as Buffer, $bae776f183aa91d1$export$2e2bcd8739ae039 as VertexBuffer, $6d7095e563bd49c3$export$2e2bcd8739ae039 as ElementBuffer, $e784d1790a77f0a9$export$2e2bcd8739ae039 as UniformBlockBuffer, $4edd0ce7f9f6daf0$export$2e2bcd8739ae039 as VertexArray, $1f22c8a97caed0f2$export$2e2bcd8739ae039 as Texture};\n//# sourceMappingURL=froxel-gl.m.js.map\n","\nexport { default as WebGLCanvas } from './webgl-canvas.js';\nexport { default as ShaderProgram } from './shader-program.js';\n\nexport { default as Buffer } from './buffer.js';\nexport { default as VertexBuffer } from './vertex-buffer.js';\nexport { default as ElementBuffer } from './element-buffer.js';\nexport { default as UniformBlockBuffer } from './uniform-block-buffer.js';\n\nexport { default as VertexArray } from './vertex-array.js';\nexport { default as Texture } from './texture.js';\n","\nimport ShaderProgram from './shader-program.js';\nimport VertexBuffer from './vertex-buffer.js';\nimport ElementBuffer from './element-buffer.js';\nimport VertexArray from './vertex-array.js';\nimport UniformBlockBuffer from './uniform-block-buffer.js';\nimport Texture from './texture.js';\nimport Buffer from './buffer.js';\n\nimport { Mat4, Vec4 } from 'froxel-math';\n\nexport default WebGLCanvas;\n\n/**\n * @typedef {'default'|'landscape'|'portrait'|'automatic'|'strict'} WebGLCanvasOrientation\n */\n\n/**\n * @typedef {Object} WebGLCanvasOptions\n * @prop {boolean} [fullscreen] Positions the canvas to cover the entire screen. default `true`\n * @prop {boolean} [stencil] Indicates if the stencil buffer should be enabled. default `false`\n * @prop {string} [background] Background color, must be a 6-digit hex RGB value. default `000000`\n * @prop {number} [width] Width of the canvas, used only when `fullscreen` is `false`. default `960`\n * @prop {number} [height] Height of the canvas, used only when `fullscreen` is `false`. default `540`\n * @prop {WebGLCanvasOrientation} [orientation] Orientation of the canvas. Defaults to `AUTOMATIC`.\n * @prop {boolean} [antialias] Controls the antialias option, set to `false` for pixel-perfect output. Default is `true`.\n * @prop {number} [scaleFactorMax] Limit of the scale factor, used only when set to greater than zero.\n * @prop {number} [scaleFactorOffs] Offset used to increase the scale factor before the Math.floor operation. Default is `0.7`.\n */\n\nconst defaultOptions = {\n\tfullscreen: true,\n\tstencil: false,\n\tbackground: '000000',\n\twidth: 960,\n\theight: 540,\n\torientation: 'automatic',\n\tantialias: true,\n\tscaleFactorMax: 0,\n\tscaleFactorOffs: 0.7,\n};\n\n/**\n * List of active canvases. Registered when the WebGLCanvas is created, and removed when it is disposed.\n */\nconst activeCanvases = [\n];\n\n/**\n * Indicates if the auto-resizer has been attached to the window.\n */\nlet autoResizerAttached = false;\n\n/**\n * \n */\nfunction autoResizeCanvas (wgl)\n{\n\tlet fullWidth = wgl.options.width;\n\tlet fullHeight = wgl.options.height;\n\n\tif (wgl.options.fullscreen && ('document' in global)) {\n\t\tfullWidth = Math.floor(global.innerWidth);\n\t\tfullHeight = Math.floor(global.innerHeight);\n\t}\n\telse {\n\t\tif (wgl.options.width === null && wgl.options.height === null)\n\t\t\tthrow new Error ('At least one screen dimension must be specified in headless mode.');\n\t}\n\n\t// Flip dimensions to ensure the desired orientation.\n\tlet currentWidth = fullWidth;\n\tlet currentHeight = fullHeight;\n\tlet flipped = false;\n\n\tif ((fullWidth < fullHeight && wgl.options.orientation === 'landscape') || (fullWidth > fullHeight && wgl.options.orientation === 'portrait')) {\n\t\tcurrentWidth = fullHeight;\n\t\tcurrentHeight = fullWidth;\n\t\tflipped = true;\n\t}\n\n\t// Get target screen dimensions.\n\tlet targetWidth = wgl.options.width;\n\tlet targetHeight = wgl.options.height;\n\n\tif (targetWidth === null || targetHeight === null)\n\t{\n\t\tif (targetWidth === null && targetHeight === null) {\n\t\t\ttargetWidth = currentWidth;\n\t\t\ttargetHeight = currentHeight;\n\t\t}\n\t\telse if (targetWidth === null)\n\t\t\ttargetWidth = Math.floor(0.5 + currentWidth * (wgl.options.height / currentHeight));\n\t\telse\n\t\t\ttargetHeight = Math.floor(0.5 + currentHeight * (wgl.options.width / currentWidth));\n\t}\n\n\t// Handle `automatic` canvas orientation.\n\tlet screenWidth = targetWidth;\n\tlet screenHeight = targetHeight;\n\n\tif (wgl.options.orientation === 'automatic' && screenWidth && screenHeight)\n\t{\n\t\tif ((screenWidth > screenHeight && currentWidth < currentHeight) || (screenWidth < screenHeight && currentWidth > currentHeight)) {\n\t\t\tscreenWidth = targetHeight;\n\t\t\tscreenHeight = targetWidth;\n\t\t}\n\t}\n\n\t// Compute canvas scale factor.\n\tlet canvasScaleFactor = 1;\n\n\tif (screenWidth && screenHeight)\n\t\tcanvasScaleFactor = Math.min(currentWidth / screenWidth, currentHeight / screenHeight);\n\telse if (screenWidth)\n\t\tcanvasScaleFactor = currentWidth / screenWidth;\n\telse if (screenHeight)\n\t\tcanvasScaleFactor = currentHeight / screenHeight;\n\n\t// ***\n\tlet tmpWidth = currentWidth;\n\tlet tmpHeight = currentHeight;\n\n\tif (screenWidth) currentWidth = screenWidth;\n\tif (screenHeight) currentHeight = screenHeight;\n\n\tlet offsX = Math.floor((tmpWidth - currentWidth*canvasScaleFactor)*0.5);\n\tlet offsY = Math.floor((tmpHeight - currentHeight*canvasScaleFactor)*0.5);\n\n\tif (flipped) {\n\t\tlet tmp = offsX;\n\t\toffsX = offsY;\n\t\toffsY = tmp;\n\t}\n\n\tlet scaleFactor = canvasScaleFactor * global.devicePixelRatio;\n\tscaleFactor = Math.floor(wgl.options.scaleFactorOffs + scaleFactor);\n\n\tif (wgl.options.scaleFactorMax > 0 && scaleFactor > wgl.options.scaleFactorMax)\n\t\tscaleFactor = wgl.options.scaleFactorMax;\n\n\tif (wgl.options.fullscreen && ('document' in global))\n\t\tglobal.document.body.style.backgroundColor = wgl.element.style.backgroundColor;\n\n\twgl.resize(currentWidth, currentHeight, false);\n\n\tif (!flipped) {\n\t\twgl.element.style.width = Math.floor(currentWidth*canvasScaleFactor+0.5) + 'px';\n\t\twgl.element.style.height = Math.floor(currentHeight*canvasScaleFactor+0.5) + 'px';\n\t}\n\telse {\n\t\twgl.element.style.width = Math.floor(currentHeight*canvasScaleFactor+0.5) + 'px';\n\t\twgl.element.style.height = Math.floor(currentWidth*canvasScaleFactor+0.5) + 'px';\n\t}\n\n\twgl.element.style.marginLeft = offsX + 'px';\n\twgl.element.style.marginTop = offsY + 'px';\n\n\twgl.globalScale = scaleFactor;\n\twgl.isFlipped = flipped;\n\n\twgl.u.initial.identity();\n\twgl.u.initial.scale(scaleFactor, scaleFactor, scaleFactor);\n\n\tif (flipped) {\n\t\twgl.u.initial.rotateZ(Math.PI/2);\n\t\twgl.u.initial.translate(-currentWidth, 0, 0);\n\t}\n\n\twgl.updateViewport();\n\n\t//console.log('logical', wgl.width, wgl.height);\t\n\t//console.log('canvas-logical', wgl.element.width, wgl.element.height);\n\t//console.log('canvas-css', wgl.element.style.width, wgl.element.style.height);\n\t//console.log('phys', wgl.physWidth, wgl.physHeight);\n\t//console.log('webGl', wgl.gl.drawingBufferWidth, wgl.gl.drawingBufferHeight);\n\t//console.log('globalScale', wgl.globalScale);\n\t//console.log('canvasScaleFactor', canvasScaleFactor);\n\n\t/* *** */\n\t//if (options.maxScaleFactor > 0 && scaleFactor > options.maxScaleFactor)\n\t//\tscaleFactor = options.maxScaleFactor;\n\n\t//_this.integerScaleFactor = Math.floor(scaleFactor + 0.5); //0.9\n};\n\n\n/**\n * WebGL2 Canvas.\n *\n * Default WebGL configuration is set as follows:\n *\n * - `DEPTH_TEST`: enabled, `clearDepth`: -1.0, `depthFunc`: GEQUAL\n * - `BLEND`: enabled, `blendEquationSeparate`: FUNC_ADD, FUNC_ADD, `blendFunc`: ONE, ONE_MINUS_SRC_ALPHA\n * - `UNPACK_PREMULTIPLY_ALPHA_WEBGL`: enabled\n * - `SCISSOR_TEST`: enabled\n *\n * @extends {WebGL2RenderingContext}\n * @param {WebGLCanvasOptions} [options]\n */\nfunction WebGLCanvas (options=null)\n{\n\tif (!autoResizerAttached)\n\t{\n\t\tglobal.onresize = function() {\n\t\t\tfor (let wgl of activeCanvases) autoResizeCanvas(wgl);\n\t\t};\n\n\t\tautoResizerAttached = true;\n\t}\n\n\tthis.init({ ...defaultOptions, ...options });\n\tactiveCanvases.push(this);\n}\n\n/**\n * Disposes the canvas and all related resources.\n */\nWebGLCanvas.prototype.dispose = function()\n{\n\tactiveCanvases.splice(activeCanvases.indexOf(this), 1);\n};\n\n\n/**\n * WebGL2 Context.\n * @private @readonly @type {WebGL2RenderingContext}\n */\nWebGLCanvas.prototype.gl = null;\n\n\n/**\n * @typedef {Object} WebGLCanvasUniforms\n * @prop {boolean} changed Indicates if the uniforms have changed and should be reloaded in the WebGL program.\n * @prop {Vec4} resolution Canvas resolution (automatically set by WebGLCanvas).\n * @prop {Mat4} initial Transformation to achieve correct target resolution and orientation (automatically set by WebGLCanvas).\n * @prop {Mat4} view Transforms coordinates to view space.\n * @prop {Mat4} projection Transforms coordinates to NDC space. Use the `setOrtho2D`, `setOrtho3D` or `setFrustrum` methods of Utils to configure its value.\n * @prop {Mat4} mvp Model-view-projection (MVP) matrix contains all transformations in a single matrix.\n */\n\n/**\n * Common uniforms for WebGL. Note that it is the responsibility of the developer to set, configure and use these uniforms (except the ones marked\n * as \"automatically set by WebGLCanvas\"). Thse are provided solely as placeholders for easy access from a known interface.\n * @readonly @type {WebGLCanvasUniforms}\n */\nWebGLCanvas.prototype.u = null;\n\n/**\n * Underlying HTML5 canvas element.\n * @readonly @type {HTMLCanvasElement}\n */\nWebGLCanvas.prototype.element = null;\n\n/**\n * Logical width of the canvas.\n * @readonly @type {number}\n */\nWebGLCanvas.prototype.width = 0;\n\n/**\n * Logical height of the canvas.\n * @readonly @type {number}\n */\nWebGLCanvas.prototype.height = 0;\n\n/**\n * Physical canvas width.\n * @readonly @type {number}\n */\nWebGLCanvas.prototype.physWidth = 0;\n\n/**\n * Physical canvas height.\n * @readonly @type {number}\n */\nWebGLCanvas.prototype.physHeight = 0;\n\n/**\n * Indicates if the canvas is flipped.\n * @readonly @type {boolean}\n */\nWebGLCanvas.prototype.isFlipped = false;\n\n/**\n * Canvas global scale.\n * @readonly @type {number}\n */\nWebGLCanvas.prototype.globalScale = 1.0;\n\n/**\n * Functions that are under a different name in WebGLCanvas from the original WebGL2RenderingContext.\n */\nconst renamedFunctions = {\n\tcreateTexture: 'genTexture',\n\tcreateBuffer: 'genBuffer',\n\tcreateVertexArray: 'genVertexArray',\n};\n\n/**\n * Initializes the instance.\n * @private\n */\nWebGLCanvas.prototype.init = function (options)\n{\n\tthis.element = document.createElement('canvas');\n\tthis.options = options;\n\n\tif (!options.fullscreen && (!options.width || !options.height))\n\t\tthrow new Error ('Option `width` or `height` is missing while `fullscreen` is `false`.');\n\n\tif (options.background.length != 6)\n\t\tthrow new Error ('Option `background` should be a 6-digit hex RGB (i.e. 000000).');\n\n\tthis.element.style.imageRendering = options.antialias ? 'auto' : 'crisp-edges';\n\tthis.element.style.backgroundColor = '#' + options.background;\n\n\tif (options.fullscreen) {\n\t\tthis.element.style.position = 'absolute';\n\t\tthis.element.style.left = '0px';\n\t\tthis.element.style.top = '0px';\n\t}\n\n\t// Get WebGL context and re-bind functions and values to the WebGLCanvas object.\n\tthis.gl = this.element.getContext('webgl2', { desynchronized: false, preserveDrawingBuffer: false, alpha: false, stencil: options.stencil });\n\n\tfor (let prop in this.gl)\n\t{\n\t\tlet val = this.gl[prop];\n\t\tswitch (typeof(val))\n\t\t{\n\t\t\tcase 'function':\n\t\t\t\tif (prop in renamedFunctions)\n\t\t\t\t\tprop = renamedFunctions[prop];\n\n\t\t\t\tthis[prop] = val.bind(this.gl);\n\t\t\t\tbreak;\n\n\t\t\tcase 'number':\n\t\t\t\tthis[prop] = val;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tconsole.log(this.getParameter(this.VERSION) + ', ' + this.getParameter(this.SHADING_LANGUAGE_VERSION));\n\n\t// Allocate placeholder for uniforms.\n\tthis.u = {\n\t\tchanged: true,\n\t\tresolution: Vec4.alloc(),\n\t\tinitial: Mat4.alloc(),\n\t\tview: Mat4.alloc(),\n\t\tprojection: Mat4.alloc(),\n\t\tmvp: Mat4.alloc(),\n\t};\n\n\t// Initialize default configuration.\n\tthis.clearColor (parseInt(options.background.substring(0,2), 16)/255.0, parseInt(options.background.substring(2,4), 16)/255.0, parseInt(options.background.substring(4,6), 16)/255.0, 1.0);\n\tthis.colorMask (true, true, true, true);\n\n\tthis.enable (this.DEPTH_TEST);\n\tthis.clearDepth (-1.0);\n\tthis.depthFunc (this.GEQUAL);\n\n\tthis.enable (this.BLEND);\n\tthis.pixelStorei (this.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n\tthis.blendEquationSeparate (this.FUNC_ADD, this.FUNC_ADD);\n\tthis.blendFunc (this.ONE, this.ONE_MINUS_SRC_ALPHA);\n\n\tthis.enable (this.SCISSOR_TEST);\n\tautoResizeCanvas(this);\n};\n\n\n/**\n * Resizes the canvas to the specified logical size.\n * @param {number} width\n * @param {number} height\n */\nWebGLCanvas.prototype.resize = function (width, height, updateViewport=true)\n{\n\tthis.width = width;\n\tthis.height = height;\n\n\tif (updateViewport)\n\t\tthis.updateViewport();\n};\n\nWebGLCanvas.prototype.updateViewport = function ()\n{\n\tthis.physWidth = this.element.width = Math.floor((this.isFlipped ? this.height : this.width) * this.globalScale);\n\tthis.physHeight = this.element.height = Math.floor((this.isFlipped ? this.width : this.height) * this.globalScale);\n\n\tthis.scissor (0, 0, this.physWidth, this.physHeight);\n\tthis.viewport (0, 0, this.physWidth, this.physHeight);\n\n\t//violet:hardware scaling? currently we're using canvas browser-level scaling.\n\t//this.v_resolution[0] = this._width;\n\t//this.v_resolution[1] = this._height;\n\tthis.u.resolution.set(this.physWidth, this.physHeight, this.isFlipped ? this.physHeight : this.physWidth, this.isFlipped ? this.physWidth : this.physHeight);\n\tthis.u.changed = true;\n};\n\n\n/**\n * Creates a shader program with the specified vertex and fragment shader source codes.\n * @param {string} vertexShaderSource\n * @param {string} fragmentShaderSource\n * @returns {ShaderProgram}\n */\nWebGLCanvas.prototype.createShaderProgram = function (vertexShaderSource, fragmentShaderSource) {\n\treturn new ShaderProgram(this, vertexShaderSource, fragmentShaderSource);\n};\n\n\n/**\n * Creates a new vertex array object.\n * @returns {VertexArray}\n */\nWebGLCanvas.prototype.createVertexArray = function () {\n\treturn new VertexArray(this);\n};\n\n\n/**\n * Creates a new buffer.\n * @param {number} target Possible values are: `ARRAY_BUFFER`, `ELEMENT_ARRAY_BUFFER`, `COPY_READ_BUFFER`, `COPY_WRITE_BUFFER`, `TRANSFORM_FEEDBACK_BUFFER`, `UNIFORM_BUFFER`, `PIXEL_PACK_BUFFER`, or `PIXEL_UNPACK_BUFFER`.\n * @param {number} usage Possible values are: `STATIC_DRAW`, `DYNAMIC_DRAW`, `STREAM_DRAW`, `STATIC_READ`, `DYNAMIC_READ`, `STREAM_READ`, `STATIC_COPY`, `DYNAMIC_COPY`, or `STREAM_COPY`.\n * @returns {VertexBuffer}\n */\nWebGLCanvas.prototype.createBuffer = function (target, usage) {\n\treturn new Buffer(this, target, usage);\n};\n\n\n/**\n * Creates a new vertex buffer.\n * @param {number} usage Possible values are: `STATIC_DRAW`, `DYNAMIC_DRAW`, `STREAM_DRAW`, `STATIC_READ`, `DYNAMIC_READ`, `STREAM_READ`, `STATIC_COPY`, `DYNAMIC_COPY`, or `STREAM_COPY`.\n * @returns {VertexBuffer}\n */\nWebGLCanvas.prototype.createVertexBuffer = function (usage) {\n\treturn new VertexBuffer(this, usage);\n};\n\n\n/**\n * Creates a new element buffer.\n * @param {number} usage Possible values are: `STATIC_DRAW`, `DYNAMIC_DRAW`, `STREAM_DRAW`, `STATIC_READ`, `DYNAMIC_READ`, `STREAM_READ`, `STATIC_COPY`, `DYNAMIC_COPY`, or `STREAM_COPY`.\n * @returns {ElementBuffer}\n */\nWebGLCanvas.prototype.createElementBuffer = function (usage) {\n\treturn new ElementBuffer(this, usage);\n};\n\n\n/**\n * Creates a new uniform block buffer.\n * @param {number} usage Possible values are: `STATIC_DRAW`, `DYNAMIC_DRAW`, `STREAM_DRAW`, `STATIC_READ`, `DYNAMIC_READ`, `STREAM_READ`, `STATIC_COPY`, `DYNAMIC_COPY`, or `STREAM_COPY`.\n * @returns {UniformBlockBuffer}\n */\nWebGLCanvas.prototype.createUniformBlockBuffer = function (usage) {\n\treturn new UniformBlockBuffer(this, usage);\n};\n\n\n/**\n * Creates a new texture object of the specified size.\n * @param {number} width - Physical texture width.\n * @param {number} height - Physical texture height.\n * @param {number} [targetWidth] - Logical texture width.\n * @param {number} [targetHeight] - Logical texture height.\n * @returns {Texture}\n */\nWebGLCanvas.prototype.createTexture = function (width, height, targetWidth=null, targetHeight=null) {\n\treturn new Texture (this, width, height, targetWidth, targetHeight);\n};\n\n\n/**\n * Loads an image from the specified URL.\n * @param {string} url\n * @returns {Promise<HTMLImageElement>}\n */\nWebGLCanvas.loadImage = function (url)\n{\n\treturn new Promise((resolve, reject) => {\n\t\tlet img = new Image();\n\t\timg.onload = () => resolve(img);\n\t\timg.onerror = () => reject('Unable to load image: ' + url);\n\t\timg.src = url;\n\t});\n};\n\n\n/**\n * Loads an image from the specified URL and creates a texture.\n * @param {string} url\n * @param {number} [mipmapLevels] - Number of levels for mipmapping. Defaults to `0`.\n * @returns {Promise<Texture>}\n */\nWebGLCanvas.prototype.loadTextureFromUrl = async function (url, mipmapLevels=0)\n{\n\tlet image = await WebGLCanvas.loadImage(url);\n\tlet texture = this.createTexture(image.width, image.height);\n\tconsole.log(texture);\n\ttexture.setMipmapLevels(mipmapLevels);\n\ttexture.upload(image);\n\treturn texture;\n};\n","\nimport WebGLCanvas from './webgl-canvas.js';\nimport UniformBlockBuffer from './uniform-block-buffer.js';\n\nexport default ShaderProgram;\n\n/**\n * Creates a WebGL GLSL Shader Program.\n * @param {WebGLCanvas} gl\n * @param {string} vertexShaderSource\n * @param {string} fragmentShaderSource\n */\nfunction ShaderProgram (gl, vertexShaderSource, fragmentShaderSource)\n{\n\t/**\n\t * Reference to the WebGLCanvas.\n\t * @readonly @type {WebGLCanvas}\n\t */\n\tthis.gl = gl;\n\n\t/**\n\t * Vertex shader resource object.\n\t * @readonly @type {WebGLShader}\n\t */\n\tthis.vertexShader = gl.createShader(gl.VERTEX_SHADER);\n\tgl.shaderSource(this.vertexShader, vertexShaderSource);\n\tgl.compileShader(this.vertexShader);\n\n\t/**\n\t * Fragment shader resource object.\n\t * @readonly @type {WebGLShader}\n\t */\n\tthis.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n\tgl.shaderSource(this.fragmentShader, fragmentShaderSource);\n\tgl.compileShader(this.fragmentShader);\n\n\t/**\n\t * Shader program resource object.\n\t * @readonly @type {WebGLProgram}\n\t */\n\tthis.program = gl.createProgram();\n\tgl.attachShader(this.program, this.vertexShader);\n\tgl.attachShader(this.program, this.fragmentShader);\n};\n\n/**\n * Links the program and throws an error if there was any problem.\n * @throws {Error}\n * @returns {ShaderProgram}\n */\nShaderProgram.prototype.linkProgram = function()\n{\n\tfor (let attribName in ShaderProgram.attribLocations) {\n\t\tthis.gl.bindAttribLocation(this.program, ShaderProgram.attribLocations[attribName], attribName);\n\t}\n\n\tthis.gl.linkProgram (this.program);\n\tif (this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS))\n\t{\n\t\tthis.gl.deleteShader(this.vertexShader)\n\t\tthis.gl.deleteShader(this.fragmentShader)\n\t\treturn this;\n\t}\n\n\tlet vertexError = this.gl.getShaderInfoLog(this.vertexShader);\n\tlet fragmentError = this.gl.getShaderInfoLog(this.fragmentShader);\n\n\tthrow new Error(\n\t\tvertexError ? ('• Vertex Shader:\\n' + vertexError + '\\n') : '' +\n\t\tfragmentError ? ('• Fragment Shader:\\n' + fragmentError) : ''\n\t);\n};\n\n/**\n * Binds an attribute location to the shader program.\n * @param {number} attribLocation\n * @param {string} attribName\n * @returns {ShaderProgram}\n */\nShaderProgram.prototype.bindAttribLocation = function (attribLocation, attribName)\n{\n\tthis.gl.bindAttribLocation(this.program, attribLocation, attribName);\n\treturn this;\n};\n\n/**\n * Map of global attribute locations.\n * @readonly @private\n * @type {Map<string, number>}\n */\nShaderProgram.attribLocations = new Map();\n\n/**\n * Binds a global attribute location to be applied to any newly created shader program.\n * @param {number} attribLocation\n * @param {string} attribName\n * @returns {ShaderProgram}\n */\nShaderProgram.bindAttribLocation = function (attribLocation, attribName)\n{\n\tthis.attribLocations[attribName] = attribLocation;\n\treturn this;\n};\n\n/**\n * Binds several global attribute locations to be applied to any newly created shader program.\n * @param {Map<string, number>} attribs\n * @returns {ShaderProgram}\n */\nShaderProgram.bindAttribLocations = function (attribs)\n{\n\tfor (let attribName in attribs) {\n\t\tthis.attribLocations[attribName] = attribs[attribName];\n\t}\n\n\treturn this;\n};\n\n/**\n * Activates the shader program for subsequent drawing operations.\n */\nShaderProgram.prototype.useProgram = function ()\n{\n\tthis.gl.useProgram(this.program);\n};\n\n/**\n * Returns the location of a uniform variable.\n * @param {string} uniformName\n * @returns {WebGLUniformLocation}\n */\nShaderProgram.prototype.getUniformLocation = function (uniformName)\n{\n\t// TODO Add cache here.\n\treturn this.gl.getUniformLocation(this.program, uniformName);\n};\n\n/**\n * Returns the location of one or more uniform variables.\n * @param {Array<string>} uniformNames\n * @returns { [key: string]: WebGLUniformLocation }\n */\nShaderProgram.prototype.getUniformLocations = function (uniformNames)\n{\n\tlet uniforms = { };\n\n\tfor (let uniformName of uniformNames) {\n\t\tuniforms[uniformName] = this.getUniformLocation(uniformName);\n\t}\n\n\treturn uniforms;\n};\n\n/**\n * Returns the index and offset of one or more uniform variables. Useful when using uniform block objects (UBO).\n * @param {Array<string>} uniformNames\n * @returns { [key: string]: { index: number, offset: number } }\n */\nShaderProgram.prototype.getUniformOffsets = function (uniformNames)\n{\n\tlet uniforms = { };\n\n\tlet indices = this.gl.getUniformIndices(this.program, uniformNames);\n\tlet offsets = this.gl.getActiveUniforms(this.program, indices, this.gl.UNIFORM_OFFSET);\n\n\tfor (let i in uniformNames) {\n\t\tuniforms[uniformNames[i]] = { index: indices[i], offset: offsets[i] };\n\t}\n\n\treturn uniforms;\n};\n\n/**\n * Returns the index of a uniform block.\n * @param {string} blockName\n * @returns {number}\n */\nShaderProgram.prototype.getUniformBlockIndex = function (blockName)\n{\n\t// TODO Add cache here?\n\treturn this.gl.getUniformBlockIndex(this.program, blockName);\n};\n\n/**\n * Returns the indices of one or more uniform blocks.\n * @param {Array<string>} blockNames\n * @returns { [key: string]: number }\n */\nShaderProgram.prototype.getUniformBlockIndices = function (blockNames)\n{\n\tlet indices = { };\n\n\tfor (let blockName of blockNames) {\n\t\tindices[blockName] = this.getUniformBlockIndex(blockName);\n\t}\n\n\treturn indices;\n};\n\n/**\n * Assigns the binding index of a uniform block buffer to a block identifier in the program.\n * @param {number|string} blockIdentifier\n * @param {number|UniformBlockBuffer} bindingIndex\n * @returns {ShaderProgram}\n */\nShaderProgram.prototype.uniformBlockBinding = function (blockIdentifier, bindingIndex)\n{\n\tif (typeof(blockIdentifier) === 'string')\n\t\tblockIdentifier = this.getUniformBlockIndex(blockIdentifier);\n\n\tif (bindingIndex instanceof UniformBlockBuffer)\n\t\tbindingIndex = bindingIndex.bindingIndex;\n\n\treturn this.gl.uniformBlockBinding (this.program, blockIdentifier, bindingIndex);\n};\n","\nimport WebGLCanvas from './webgl-canvas.js';\nimport Buffer from './buffer.js';\n\nexport default class UniformBlockBuffer extends Buffer\n{\n\t/**\n\t * Uniform block binding index. Set using `bindBufferBase`.\n\t * @readonly @type {number}\n\t */\n\tbindingIndex;\n\n\t/**\n\t * Creates a buffer for the UNIFORM_BUFFER target.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} usage\n\t */\n\tconstructor (gl, usage)\n\t{\n\t\tsuper (gl, gl.UNIFORM_BUFFER, usage);\n\t}\n\n\t/**\n\t * Binds the buffer to the UNIFORM_BUFFER binding point at a given index. \n\t * @param {number} index\n\t * @returns {UniformBlockBuffer}\n\t */\n\tbindBufferBase (index)\n\t{\n\t\t this.gl.bindBufferBase(this.target, this.bindingIndex = index, this.buffer);\n\t\t return this;\n\t}\n};\n","\nimport WebGLCanvas from './webgl-canvas.js';\n\n/**\n * Represents a WebGL buffer.\n */\nexport default class Buffer\n{\n\t/**\n\t * Reference to the WebGLCanvas.\n\t * @readonly @type {WebGLCanvas}\n\t */\n\tgl;\n\n\t/**\n\t * Buffer target.\n\t * @type {number}\n\t */\n\ttarget;\n\n\t/**\n\t * Buffer usage mode.\n\t * @type {number}\n\t */\n\tusage;\n\n\t/**\n\t * Buffer object resource.\n\t * @type {WebGLBuffer}\n\t */\n\tbuffer;\n \n\t/**\n\t * Creates a WebGL buffer.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} target\n\t * @param {number} usage\n\t */\n\tconstructor (gl, target, usage)\n\t{\n\t\tthis.gl = gl;\n\t\tthis.target = target;\n\t\tthis.usage = usage;\n\t\tthis.buffer = gl.genBuffer();\n\t}\n\n\t/**\n\t * Binds the buffer to its WebGL target.\n\t * @returns {Buffer}\n\t */\n\tbindBuffer()\n\t{\n\t\tthis.gl.bindBuffer(this.target, this.buffer);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unbinds the buffer from its GPU buffer target.\n\t * @returns {Buffer}\n\t */\n\tunbindBuffer()\n\t{\n\t\tthis.gl.bindBuffer(this.target, null);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Initializes and creates the buffer object's data store.\n\t * @param {ArrayBufferView} srcData\n\t * @param {number} srcOffset?\n\t * @returns {Buffer}\n\t */\n\tbufferData (srcData, srcOffset=0)\n\t{\n\t\tthis.bindBuffer();\n\t\tthis.gl.bufferData(this.target, srcData, this.usage, srcOffset);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Allocates the specified number of bytes for the buffer.\n\t * @param {number} numBytes\n\t * @returns {Buffer}\n\t */\n\tallocate (numBytes)\n\t{\n\t\tthis.bindBuffer();\n\t\tthis.gl.bufferData(this.target, numBytes, this.usage);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Updates a subset of the buffer object's data store. \n\t * @param {number} dstByteOffset\n\t * @param {ArrayBufferView} srcData\n\t * @param {number} srcOffset?\n\t * @param {number} length?\n\t * @returns {Buffer}\n\t */\n\tbufferSubData (dstByteOffset, srcData, srcOffset=0, length=0)\n\t{\n\t\tthis.bindBuffer();\n\t\tthis.gl.bufferSubData(this.target, dstByteOffset, srcData, srcOffset, length ? length : srcData.length);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Deletes the buffer.\n\t */\n\tdeleteBuffer()\n\t{\n\t\tthis.gl.deleteBuffer(this.buffer);\n\t}\n};\n","\nimport WebGLCanvas from './webgl-canvas.js';\nimport Buffer from './buffer.js';\n\nexport default class VertexBuffer extends Buffer\n{\n\t/**\n\t * Creates a buffer for the ARRAY_BUFFER target.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} usage\n\t */\n\tconstructor (gl, usage)\n\t{\n\t\tsuper (gl, gl.ARRAY_BUFFER, usage);\n\t}\n};\n","\nimport WebGLCanvas from './webgl-canvas.js';\nimport Buffer from './buffer.js';\n\nexport default class ElementBuffer extends Buffer\n{\n\t/**\n\t * Creates a buffer for the ELEMENT_ARRAY_BUFFER target.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} usage\n\t */\n\tconstructor (gl, usage)\n\t{\n\t\tsuper (gl, gl.ELEMENT_ARRAY_BUFFER, usage);\n\t}\n};\n","\nimport WebGLCanvas from './webgl-canvas.js';\n\nexport default VertexArray;\n\n/**\n * Creates a Vertex Array Object (VAO).\n * @param {WebGLCanvas} gl\n */\nfunction VertexArray (gl)\n{\n\t/**\n\t * Reference to the WebGLCanvas.\n\t * @readonly @type {WebGLCanvas}\n\t */\n\tthis.gl = gl;\n\n\t/**\n\t * Vertex array object resource.\n\t * @type {WebGLVertexArrayObject}\n\t */\n\tthis.vertexArray = gl.genVertexArray();\n};\n\n/**\n * Binds the vertex array object to the GPU.\n */\nVertexArray.prototype.bindVertexArray = function()\n{\n\tthis.gl.bindVertexArray(this.vertexArray);\n};\n\n/**\n * Unbinds the vertex array object from the GPU.\n */\nVertexArray.prototype.unbindVertexArray = function()\n{\n\tthis.gl.bindVertexArray(null);\n};\n","\nimport WebGLCanvas from './webgl-canvas.js';\n\n/**\n * @typedef {'NEAREST' | 'LINEAR'} TextureFilterType\n */\n/**\n * @typedef {'REPEAT' | 'CLAMP_TO_EDGE' | 'MIRRORED_REPEAT'} TextureWrapMode\n */\n\n/**\n * WebGLCanvas Texture Object.\n */\nexport default class Texture\n{\n\t/**\n\t * Reference to the WebGLCanvas.\n\t * @readonly @type {WebGLCanvas}\n\t */\n\tgl;\n\n\t/**\n\t * Texture object resource.\n\t * @readonly @type {WebGLTexture}\n\t */\n\ttexture;\n\n\t/**\n\t * Texture width (physical width).\n\t * @readonly @type {number}\n\t */\n\twidth;\n\n\t/**\n\t * Texture height (physical height).\n\t * @readonly @type {number}\n\t */\n\theight;\n\n\t/**\n\t * Target width originally requested (logical width).\n\t * @readonly @type {number}\n\t */\n\ttargetWidth;\n\n\t/**\n\t * Target height originally requested (logical height).\n\t * @readonly @type {number}\n\t */\n\ttargetHeight;\n\n\t/**\n\t * Scale of the texture (physical width / logical width).\n\t * @readonly @type {number}\n\t */\n\tscale;\n\n\t/**\n\t * Texture filter type. Defaults to `LINEAR`.\n\t * @readonly @type {TextureFilterType}\n\t */\n\tfilterType;\n\n\t/**\n\t * Texture wrap mode. Defaults to `CLAMP_TO_EDGE`.\n\t * @readonly @type {TextureWrapMode}\n\t */\n\twrapMode;\n\n\t/**\n\t * Number of mipmap levels (use 0 to disable). Default is `0`.\n\t * @readonly @type {number}\n\t */\n\tmipmapLevels;\n\n\t/**\n\t * Indicates if the texture storage has already been allocated.\n\t * @readonly @private @type {boolean}\n\t */\n\tallocated;\n\n\t/**\n\t * Creates an empty texture object of the specified size.\n\t * @param {WebGLCanvas} gl\n\t * @param {number} width - Physical texture width.\n\t * @param {number} height - Physical texture height.\n\t * @param {number} [targetWidth] - Logical texture width.\n\t * @param {number} [targetHeight] - Logical texture height.\n\t */\n\tconstructor (gl, width, height, targetWidth=null, targetHeight=null)\n\t{\n\t\tthis.gl = gl;\n\t\tthis.texture = gl.genTexture();\n\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tthis.targetWidth = targetWidth ?? width;\n\t\tthis.targetHeight = targetHeight ?? height;\n\t\tthis.scale = this.width / this.targetWidth;\n\n\t\tthis.allocated = false;\n\t\tthis.mipmapLevels = 0;\n\t\tthis.wrapMode = 'CLAMP_TO_EDGE';\n\t\tthis.filterType = 'LINEAR';\n\t}\n\n\t/**\n\t * Binds the texture to the `TEXTURE_2D` target and allocates the texture storage if not allocated yet.\n\t * @returns {Texture}\n\t */\n\tbindTexture()\n\t{\n\t\tthis.gl.bindTexture (this.gl.TEXTURE_2D, this.texture);\n\t\tif (this.allocated !== false) return this;\n\n\t\tthis.allocated = null;\n\t\tthis.allocate();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Allocates the texture storage.\n\t * @returns {Texture}\n\t */\n\tallocate()\n\t{\n\t\tif (this.allocated === true)\n\t\t\treturn this;\n\n\t\tthis.allocated = true;\n\t\tthis.bindTexture().applyFilter().applyWrap();\n\n\t\tif (this.mipmapLevels > 0)\n\t\t\tthis.gl.texStorage2D(this.gl.TEXTURE_2D, this.mipmapLevels, this.gl.RGBA8, this.width, this.height);\n\t\telse\n\t\t\tthis.gl.texStorage2D(this.gl.TEXTURE_2D, 1, this.gl.RGBA8, this.width, this.height);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Applies the texture filter.\n\t * @private\n\t * @param {boolean} [bindTexture]\n\t * @returns {Texture}\n\t */\n\tapplyFilter (bindTexture=false)\n\t{\n\t\tif (bindTexture) this.bindTexture();\n\n\t\tlet minFilter = this.gl.LINEAR;\n\t\tlet magFilter = this.gl.LINEAR;\n\n\t\tif (this.filterType === 'NEAREST')\n\t\t\tminFilter = magFilter = this.gl.NEAREST;\n\n\t\tif (this.mipmapLevels > 0)\n\t\t{\n\t\t\tminFilter = this.gl.LINEAR_MIPMAP_LINEAR\n\n\t\t\tif (this.filterType === 'NEAREST')\n\t\t\t\tminFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n\t\t}\n\n\t\tthis.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, minFilter);\n\t\tthis.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, magFilter);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Applies the texture wrap mode.\n\t * @private\n\t * @param {boolean} [bindTexture]\n\t * @returns {Texture}\n\t */\n\tapplyWrap (bindTexture=false)\n\t{\n\t\tif (bindTexture) this.bindTexture();\n\n\t\tlet wrapMode = this.gl.CLAMP_TO_EDGE;\n\n\t\tif (this.wrapMode === 'REPEAT')\n\t\t\twrapMode = this.gl.REPEAT;\n\t\telse if (this.wrap === 'MIRRORED_REPEAT')\n\t\t\twrapMode = this.gl.MIRRORED_REPEAT;\n\n\t\tthis.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, wrapMode);\n\t\tthis.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, wrapMode);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the texture filter type.\n\t * @param {TextureFilterType} filterType\n\t * @returns {Texture}\n\t */\n\tsetFilter (filterType)\n\t{\n\t\tthis.filterType = filterType;\n\t\treturn this.allocated === true ? this.applyFilter(true) : this;\n\t}\n\n\t/**\n\t * Sets the texture wrap mode.\n\t * @param {TextureWrapMode} wrapMode\n\t * @returns {Texture}\n\t */\n\tsetWrapMode (wrapMode)\n\t{\n\t\tthis.wrapMode = wrapMode;\n\t\treturn this.allocated === true ? this.applyWrap(true) : this;\n\t}\n\n\t/**\n\t * Sets the number of mipmap levels. Valid only if texture data has not been allocated yet.\n\t * @param {number} numLevels\n\t * @returns {Texture}\n\t */\n\tsetMipmapLevels (numLevels)\n\t{\n\t\tif (this.allocated === true)\n\t\t\treturn this;\n\n\t\tthis.mipmapLevels = Math.max(0, numLevels);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Uploads data to the GPU from the specified image.\n\t * @param {HTMLImageElement} image\n\t * @param {number} [offsX] - Target X offset.\n\t * @param {number} [offsY] - Target Y offset;\n\t * @returns {Texture}\n\t */\n\tupload (image, offsX=0, offsY=0)\n\t{\n\t\tthis.bindTexture();\n\t\tthis.gl.texSubImage2D(this.gl.TEXTURE_2D, 0, offsX, offsY, Math.min(image.width, this.width), Math.min(image.height, this.height), this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\n\n\t\tif (this.mipmapLevels > 0)\n\t\t\tthis.gl.generateMipmap(this.gl.TEXTURE_2D);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Makes the texture active on the specified texture unit.\n\t * @param {number} unit - Texture unit index (0 to 15).\n\t * @returns {Texture}\n\t */\n\tactiveTexture (unit)\n\t{\n\t\tthis.gl.activeTexture(this.gl.TEXTURE0+(unit&15));\n\t\tthis.bindTexture();\n\t\treturn this;\n\t}\n};\n"],"names":["Vec4","$k7heJ$Vec4","Mat4","$k7heJ$Mat4","$parcel$global","globalThis","self","window","global","$8130a8013106f3d1$export$2e2bcd8739ae039","gl","target","usage","buffer","constructor","genBuffer","bindBuffer","unbindBuffer","bufferData","srcData","srcOffset","allocate","numBytes","bufferSubData","dstByteOffset","length","deleteBuffer","$e784d1790a77f0a9$export$2e2bcd8739ae039","bindingIndex","UNIFORM_BUFFER","bindBufferBase","index","$f833e504115047ce$export$2e2bcd8739ae039","$f833e504115047ce$var$ShaderProgram","vertexShaderSource","fragmentShaderSource","vertexShader","createShader","VERTEX_SHADER","shaderSource","compileShader","fragmentShader","FRAGMENT_SHADER","program","createProgram","attachShader","prototype","linkProgram","attribName","attribLocations","bindAttribLocation","getProgramParameter","LINK_STATUS","deleteShader","vertexError","getShaderInfoLog","fragmentError","Error","attribLocation","Map","bindAttribLocations","attribs","useProgram","getUniformLocation","uniformName","getUniformLocations","uniformNames","uniforms","getUniformOffsets","indices","getUniformIndices","offsets","getActiveUniforms","UNIFORM_OFFSET","i","offset","getUniformBlockIndex","blockName","getUniformBlockIndices","blockNames","uniformBlockBinding","blockIdentifier","$bae776f183aa91d1$export$2e2bcd8739ae039","ARRAY_BUFFER","$6d7095e563bd49c3$export$2e2bcd8739ae039","ELEMENT_ARRAY_BUFFER","$4edd0ce7f9f6daf0$export$2e2bcd8739ae039","$4edd0ce7f9f6daf0$var$VertexArray","vertexArray","genVertexArray","bindVertexArray","unbindVertexArray","$1f22c8a97caed0f2$export$2e2bcd8739ae039","texture","width","height","targetWidth","targetHeight","scale","filterType","wrapMode","mipmapLevels","allocated","genTexture","bindTexture","TEXTURE_2D","applyFilter","applyWrap","texStorage2D","RGBA8","minFilter","LINEAR","magFilter","NEAREST","LINEAR_MIPMAP_LINEAR","NEAREST_MIPMAP_LINEAR","texParameteri","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","CLAMP_TO_EDGE","REPEAT","wrap","MIRRORED_REPEAT","TEXTURE_WRAP_S","TEXTURE_WRAP_T","setFilter","setWrapMode","setMipmapLevels","numLevels","Math","max","upload","image","offsX","offsY","texSubImage2D","min","RGBA","UNSIGNED_BYTE","generateMipmap","activeTexture","unit","TEXTURE0","$87df07883f23e949$export$2e2bcd8739ae039","$87df07883f23e949$var$WebGLCanvas","$87df07883f23e949$var$defaultOptions","fullscreen","stencil","background","orientation","antialias","scaleFactorMax","scaleFactorOffs","$87df07883f23e949$var$activeCanvases","$87df07883f23e949$var$autoResizerAttached","$87df07883f23e949$var$autoResizeCanvas","wgl","fullWidth","options","fullHeight","floor","innerWidth","innerHeight","currentWidth","currentHeight","flipped","screenWidth","screenHeight","canvasScaleFactor","tmpWidth","tmpHeight","tmp","scaleFactor","devicePixelRatio","document","body","style","backgroundColor","element","resize","marginLeft","marginTop","globalScale","isFlipped","u","initial","identity","rotateZ","PI","translate","updateViewport","onresize","init","push","dispose","splice","indexOf","physWidth","physHeight","$87df07883f23e949$var$renamedFunctions","createTexture","createBuffer","createVertexArray","createElement","prop","imageRendering","position","left","top","getContext","desynchronized","preserveDrawingBuffer","alpha","val","bind","console","log","getParameter","VERSION","SHADING_LANGUAGE_VERSION","changed","resolution","alloc","view","projection","mvp","clearColor","parseInt","substring","colorMask","enable","DEPTH_TEST","clearDepth","depthFunc","GEQUAL","BLEND","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","blendEquationSeparate","FUNC_ADD","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","SCISSOR_TEST","scissor","viewport","set","createShaderProgram","createVertexBuffer","createElementBuffer","createUniformBlockBuffer","loadImage","url","Promise","resolve","reject","img","Image","onload","onerror","src","loadTextureFromUrl","WebGLCanvas","ShaderProgram","Buffer","VertexBuffer","ElementBuffer","UniformBlockBuffer","VertexArray","Texture"],"version":3,"file":"froxel-gl.m.js.map"}